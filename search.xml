<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM之GC</title>
    <url>/2020/06/07/JVM%E4%B9%8BGC/</url>
    <content><![CDATA[<ol>
<li><h3 id="垃圾回收及其算法"><a href="#垃圾回收及其算法" class="headerlink" title="垃圾回收及其算法"></a>垃圾回收及其算法</h3><p>如图：</p>
<p><img src="https://s1.ax1x.com/2020/06/07/tRPIcn.png" alt="tRPIcn.png"></p>
<p><strong>垃圾收集主要是针对堆和方法区进行</strong>。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<a id="more"></a>
</li>
<li><h3 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h3><ol>
<li><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();<span class="comment">//a的引用计数器为1</span></span><br><span class="line">        Test b = <span class="keyword">new</span> Test();<span class="comment">//b的引用计数器为1</span></span><br><span class="line">        a.instance = b;<span class="comment">//b的引用计数器为2</span></span><br><span class="line">        b.instance = a;<span class="comment">//a的引用计数器为2</span></span><br><span class="line">        a = <span class="keyword">null</span>;<span class="comment">//a的引用计数器为1</span></span><br><span class="line">        b = <span class="keyword">null</span>;<span class="comment">//b的引用计数器为1</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<p><strong>注意对象与引用的区别</strong>，简单的说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user;<span class="comment">//则是一个引用</span></span><br><span class="line">user = <span class="keyword">new</span> User();<span class="comment">//那么new User()就是一个对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h4><p>通过一系列的<strong>“GC roots”</strong>对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。<strong>要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记</strong><br><strong>过程。两次标记后仍然是可回收对象，则将面临回收。</strong></p>
<p><strong>可以作为GC roots的对象：</strong></p>
<ul>
<li>虚拟机栈中的局部变量所引用的对象</li>
<li>JNI中的变量所引用的对象</li>
<li>方法区中的静态变量与常量所引用的对象</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
</li>
<li><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型：</p>
<ol>
<li><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>如上，使用new一个新对象的方式来创建强引用<strong>，当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收</strong>。因此强引用是造成 Java 内存泄漏的主要原因之一。</p>
</li>
<li><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<p>如上，使用SoftReference类来创建软引用，<strong>被软引用关联的对象只有在内存不足时才会被回收</strong>。</p>
</li>
<li><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<p>如上，使用WeakReference类来创建弱引用，<strong>被弱引用关联的对象一定会被回收，也就是说，被弱引用关联的对象只能活到下一次垃圾回收发生之前。</strong></p>
</li>
<li><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<p>如上，使用PhantomReference类来创建虚引用，<strong>虚引用的主要作用是跟踪对象被垃圾回收的状态(为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知)</strong></p>
</li>
</ol>
</li>
<li><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ol>
<li><h4 id="标记-清除算法-mark-sweep"><a href="#标记-清除算法-mark-sweep" class="headerlink" title="标记-清除算法(mark-sweep)"></a>标记-清除算法(mark-sweep)</h4><p>最基础的垃圾回收算法，分为两个阶段，标记和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图：</p>
<p><img src="https://s1.ax1x.com/2020/06/07/tRKbHH.png" alt="tRKbHH.png"></p>
<p>缺点：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致后续无法给大对象分配内存。</li>
</ul>
</li>
<li><h4 id="标记-整理-mark-compact"><a href="#标记-整理-mark-compact" class="headerlink" title="标记-整理(mark-compact)"></a>标记-整理(mark-compact)</h4><p>标记阶段和 Mark-Sweep 算法相同，<strong>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象</strong>。如图：</p>
<p><img src="https://s1.ax1x.com/2020/06/07/tRQpJ1.png" alt="tRQpJ1.png"></p>
<p>优点：不会产生内存碎片</p>
<p>缺点：需要移动大量对象，处理效率比较低</p>
</li>
<li><h4 id="复制算法-copying"><a href="#复制算法-copying" class="headerlink" title="复制算法(copying)"></a>复制算法(copying)</h4><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。如图：</p>
<p><img src="https://s1.ax1x.com/2020/06/07/tRGkaF.png" alt="tRGkaF.png"></p>
<p>缺点：只使用了内存的一半，且存活对象增多的话，Copying 算法的效率会大大降低。</p>
<p>优点：不会产生内存碎片</p>
</li>
<li><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>
<ul>
<li><p>新生代：采用复制算法</p>
<p>因为新生代中每次垃圾回收都要回收大部分对象，只有少量对象存活，所需要付出的时间代价比较小。但通常并不是按照1:1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(FromSpace，ToSpace)(比例8:1:1)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p>
</li>
<li><p>老年代：标记-清除算法或标记-整理算法</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>offer</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax学习</title>
    <url>/2020/06/18/Ajax%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ol>
<li><h3 id="ajax介绍"><a href="#ajax介绍" class="headerlink" title="ajax介绍"></a>ajax介绍</h3><p>ajax是异步的javaScript和xml，是一种无需重新加载整个网页的情况下，能够更新部分网页数据的技术（比如我们常见的搜索引擎框中输入关键词，就利用到了ajax发送请求到服务器，服务器返回一个搜索列表）</p>
</li>
<li><h3 id="ajax再介绍"><a href="#ajax再介绍" class="headerlink" title="ajax再介绍"></a>ajax再介绍</h3><ol>
<li>相比传统网页（即不使用ajax的网页），想要更新内容或提交一个表单，都需要重新加载整个页面，而使用ajax的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。增强B/S的体验</li>
<li>Ajax的核心是XMLHttpRequest对象（XHR）。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
<li>通过Ajax方法，可以使用Http GET和Http Post从远程服务器上请求文本、HTML、XML或JSON数据—-同时可以将这些数据直接载入网页的被选元素中。</li>
</ol>
</li>
<li><h3 id="ajax使用概览"><a href="#ajax使用概览" class="headerlink" title="ajax使用概览"></a>ajax使用概览</h3><ol>
<li><p>肯定先要导入jQuery包</p>
</li>
<li><p>jQuery Ajax本质就是XMLHttpRequest，对他进行了封装，下面就是他的一些方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>JQuery.get(...)</span><br><span class="line">           所有参数：</span><br><span class="line">           		url:待载入的页面URL地址</span><br><span class="line">           		data:待发送Key/Value参数</span><br><span class="line">           		success:载入成功时回调函数</span><br><span class="line">           		dataType:返回内容格式（xml，json，script，text，html）（一般不用）</span><br><span class="line">             </span><br><span class="line"><span class="number">2.</span>JQuery.post(...)</span><br><span class="line">		  所有参数：</span><br><span class="line">          		url:待载入的页面URL地址</span><br><span class="line">           		data:待发送Key/Value参数</span><br><span class="line">           		success:载入成功时回调函数</span><br><span class="line">           		dataType:返回内容格式（xml，json，script，text，html）（一般不用）</span><br><span class="line">            </span><br><span class="line"><span class="number">3.</span>jQuery.ajax(...)</span><br><span class="line">          所有参数见：https:<span class="comment">//www.runoob.com/jquery/ajax-ajax.html</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和springmvc中@ResponseBody注解配合使用</p>
<p>springMVC中的@ResponseBody负责返回一个json字符串，这样直接可以通过ajax发送请求获取json数据，然后解析渲染</p>
<a id="more"></a>
</li>
</ol>
</li>
<li><h3 id="使用ajax做一个登录小demo"><a href="#使用ajax做一个登录小demo" class="headerlink" title="使用ajax做一个登录小demo"></a>使用ajax做一个登录小demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些都是代码片段</span></span><br><span class="line"><span class="comment">//假设我们项目名logindemo，项目地址：http://localhost:8080/logindemo</span></span><br><span class="line"><span class="comment">//name和password都写死了的，分别为admin和123456</span></span><br><span class="line"><span class="comment">//后端代码</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/selectName"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    String msg = <span class="string">"name is null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="keyword">null</span>) <span class="keyword">return</span> msg;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="string">"admin"</span>.equals(name))) msg = <span class="string">"name is inValid"</span>;</span><br><span class="line">        <span class="keyword">else</span> msg = <span class="string">"ok"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/selectPass"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectPass</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">    String msg = <span class="string">"password is null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(password == <span class="keyword">null</span>) <span class="keyword">return</span> msg;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(!(<span class="string">"123456"</span>.equals(password))) msg = <span class="string">"password is inValid"</span>;</span><br><span class="line">        <span class="keyword">else</span> msg = <span class="string">"ok"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String name,String password)</span></span>&#123;</span><br><span class="line">    String msg = <span class="string">"name or pass is null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="keyword">null</span> || password == <span class="keyword">null</span>) <span class="keyword">return</span> msg;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="string">"admin"</span>.equals(name))) msg = <span class="string">"name is inValid"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!(<span class="string">"123456"</span>.equals(password))) msg = <span class="string">"password is inValid"</span>;</span><br><span class="line">        <span class="keyword">else</span> msg = <span class="string">"name and password are both valid"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--前端代码--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html;charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;登录界面&lt;/title&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        pageContext.setAttribute(<span class="string">"APP_PATH"</span>, request.getContextPath());</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;!--引入jQuery--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    web路径：</span><br><span class="line">        不以/开始的相对路径：找资源，以当前资源的路径为基准，经常容易出问题</span><br><span class="line">        以/开始的相对路径：找资源，以服务器的路径为标准(http:<span class="comment">//localhost:8080)</span></span><br><span class="line">        比如：$&#123;APP_PATH&#125;可以代表路径：http:<span class="comment">//localhost:8080/crud</span></span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;script type="text/javascript" src="$&#123;APP_PATH&#125;/staticSources/jquery1.11.0/jquery-1.11.0.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    	<span class="function">function <span class="title">nameInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.post(&#123;</span><br><span class="line">                url:<span class="string">"$&#123;APP_PATH&#125;/selectName"</span>,</span><br><span class="line">                data:&#123;<span class="string">"name"</span>:$(<span class="string">"#name"</span>).val()&#125;,</span><br><span class="line">                success:function(result)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(result.toString() == <span class="string">'ok'</span>)&#123;</span><br><span class="line">                        $(<span class="string">"#infoName"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>);</span><br><span class="line">				   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       $(<span class="string">"#infoName"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>);</span><br><span class="line">                   	&#125;</span><br><span class="line">                    $(<span class="string">"#infoName"</span>).html(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意两种ajax的写法区别</span></span><br><span class="line">        <span class="function">function <span class="title">passInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.post(<span class="string">"$&#123;APP_PATH&#125;/selectPass"</span>,&#123;<span class="string">"password"</span>:$(<span class="string">"#pass"</span>).val()&#125;,function(result)&#123;</span><br><span class="line">                <span class="keyword">if</span>(result.toString() == <span class="string">'ok'</span>)&#123;</span><br><span class="line">                        $(<span class="string">"#infoPass"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>);</span><br><span class="line">				   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       $(<span class="string">"#infoPass"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>);</span><br><span class="line">                   	&#125;</span><br><span class="line">                    $(<span class="string">"#infoPass"</span>).html(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        用户名：</span><br><span class="line">        &lt;input type = <span class="string">"text"</span> id = <span class="string">"name"</span> onblur = <span class="string">"nameInfo()"</span>/&gt;</span><br><span class="line">        &lt;!--span里面就是发送ajax请求后服务器返回name的情况并显示--&gt;</span><br><span class="line">        &lt;span id = "infoName"&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        密码：</span><br><span class="line">        &lt;input type = <span class="string">"password"</span> id = <span class="string">"pass"</span> onblur = <span class="string">"passInfo()"</span>/&gt;</span><br><span class="line">        &lt;!--span里面就是发送ajax请求后服务器返回pass的情况并显示--&gt;</span><br><span class="line">        &lt;span id = "infoPass"&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">		&lt;!--doLogin()自己写的js函数--&gt;</span><br><span class="line">        &lt;input type = <span class="string">"button"</span> id = <span class="string">"login"</span> onclick = <span class="string">"doLogin()"</span>/&gt; </span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="ajax总结"><a href="#ajax总结" class="headerlink" title="ajax总结"></a>ajax总结</h3><ol>
<li>编写对应处理的Controller，返回json格式或字符串格式数据；</li>
<li>编写ajax请求（如上例两种方法），大致需要完成三个要求：<ol>
<li>url请求地址</li>
<li>data键值对</li>
<li>success回调函数</li>
</ol>
</li>
<li>给ajax绑定事件，如点击.click，失去焦点.onblur，键盘弹起.keyup。更多事件可查看：<a href="https://www.jquery123.com/category/attributes/" target="_blank" rel="external nofollow noopener noreferrer">https://www.jquery123.com/category/attributes/</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端基础</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM之运行时数据区域</title>
    <url>/2020/06/06/JVM%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<ol>
<li><h3 id="先来看看运行时数据区域长啥样"><a href="#先来看看运行时数据区域长啥样" class="headerlink" title="先来看看运行时数据区域长啥样"></a>先来看看运行时数据区域长啥样</h3><p><img src="https://s1.ax1x.com/2020/06/06/tcK3Pf.png" alt="tcK3Pf.png"></p>
<p>注意：</p>
<ul>
<li>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束而创建/销毁(在HotspotVM内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</li>
<li>线程共享区域随虚拟机的启动/关闭而创建/销毁。</li>
<li><strong>直接内存并不是JVM运行时数据区的一部分</strong>，但也会被频繁的使用：在JDK 1.4引入的NIO提供了基于Channel与Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后使用DirectByteBuffer对象作为这块内存的引用进行操作(详见：Java I/O 扩展)，这样就避免了在Java堆和Native堆中来回复制数据，因此在一些场景中可以显著提高性能。</li>
</ul>
</li>
<li><h3 id="再来看看各个区域的大概功能"><a href="#再来看看各个区域的大概功能" class="headerlink" title="再来看看各个区域的大概功能"></a>再来看看各个区域的大概功能</h3><p><img src="https://s1.ax1x.com/2020/06/06/tcMd6e.png" alt="tcMd6e.png"></p>
<a id="more"></a>
</li>
<li><h3 id="接下来仔细分析一下各个区域"><a href="#接下来仔细分析一下各个区域" class="headerlink" title="接下来仔细分析一下各个区域"></a>接下来仔细分析一下各个区域</h3><ol>
<li><h4 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h4><ul>
<li>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</li>
<li>正在执行java方法的话，<strong>计数器记录的是虚拟机字节码指令的地址(当前指令的地址)</strong>。如果还是Native方法，则为空。</li>
<li>这个内存区域是唯一一个在虚拟机中<strong>没有规定任何OutOfMemoryError(OOM)情况的区域</strong>。</li>
</ul>
</li>
<li><h4 id="java虚拟机栈-线程私有"><a href="#java虚拟机栈-线程私有" class="headerlink" title="java虚拟机栈(线程私有)"></a>java虚拟机栈(线程私有)</h4><p>是描述java方法执行的内存模型，每个方法在执行的同时都会<strong>创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，如图：</p>
<p><img src="https://s1.ax1x.com/2020/06/06/tclSKg.png" alt="tclSKg.png"></p>
</li>
<li><h4 id="本地方法栈-线程私有"><a href="#本地方法栈-线程私有" class="headerlink" title="本地方法栈(线程私有)"></a>本地方法栈(线程私有)</h4><p>本地方法栈和java虚拟机栈作用类似，<strong>区别是虚拟机栈为执行Java方法服务, 而本地方法栈则为Native方法服务，</strong>如果一个VM实现使用C-linkage模型来支持Native调用，那么该栈将会是一个C栈，但HotSpot VM直接就把本地方法栈和虚拟机栈合二为一。</p>
</li>
<li><h4 id="堆-heap-线程共享"><a href="#堆-heap-线程共享" class="headerlink" title="堆(heap-线程共享)"></a>堆(heap-线程共享)</h4><p>是被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM采用分代收集算法，因此Java堆从GC的角度还可以细分为：新生代(Eden区 、 FromSurvivor区和ToSurvivor区)和老年代。</p>
</li>
<li><h4 id="方法区-永久代-线程共享"><a href="#方法区-永久代-线程共享" class="headerlink" title="方法区/永久代(线程共享)"></a>方法区/永久代(线程共享)</h4><ul>
<li>我们常说的永久代(Permanent Generation)，<strong>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。HotSpot VM把GC分代收集扩展至方法区，即使用Java堆的永久代来实现方法区，这样HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载，因此收益一般很小)。</li>
<li><strong>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</strong></li>
<li>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次Full GC之后永久代的大小都会改变，所以经常会抛出OutOfMemoryError异常。为了更容易管理方法区，<strong>从JDK 1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。<strong>类的元数据放入native memory，字符串池和类的静态变量放入java堆中</strong>，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</li>
<li><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/24/hello-world/</url>
    <content><![CDATA[<h1 id="Welcome-to-yinjiawei’s-blog"><a href="#Welcome-to-yinjiawei’s-blog" class="headerlink" title="Welcome to yinjiawei’s blog!"></a>Welcome to <a href="https://vampiresmile.github.io/">yinjiawei’s blog</a>!</h1>]]></content>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2020/07/17/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<ol>
<li><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>java推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储的每个元素的数据类型，否则很容易引发ClassCastException异常</p>
</li>
<li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>java泛型是jdk5中引入的新特性。泛型提供了编译时类型安全监测机制，该机制允许我们在编译时检测到非法的类型数据</p>
</li>
<li><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数</p>
</li>
<li><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>类型安全。</li>
<li>避免了强制类型的转换。</li>
</ol>
</li>
<li><h3 id="常用的泛型标识符：T，E，K，V"><a href="#常用的泛型标识符：T，E，K，V" class="headerlink" title="常用的泛型标识符：T，E，K，V"></a>常用的泛型标识符：T，E，K，V</h3><a id="more"></a>
</li>
<li><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ol>
<li><h4 id="泛型类的定义语法"><a href="#泛型类的定义语法" class="headerlink" title="泛型类的定义语法"></a>泛型类的定义语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&lt;泛型标识,泛型标识...&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> 泛型标识 变量名;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="泛型类的使用语法"><a href="#泛型类的使用语法" class="headerlink" title="泛型类的使用语法"></a>泛型类的使用语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk1.7之前</span></span><br><span class="line">类名&lt;具体的数据类型&gt; 对象名 = <span class="keyword">new</span> 类名&lt;具体的数据类型名&gt;();</span><br><span class="line"><span class="comment">//jdk1.7之后</span></span><br><span class="line">类名&lt;具体的数据类型&gt; 对象名 = <span class="keyword">new</span> 类名&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如我们有一个泛型类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(T name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>泛型类在创建对象的时候如果没有指定T的具体数据类型，将会按照Object类型来操作，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果对Animal使用如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Animal an = <span class="keyword">new</span> Animal();<span class="comment">//没有指定Animal中T的具体数据类型</span></span><br><span class="line">    Object name = an.getName();<span class="comment">//那么这里得到的就是Object对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型类不支持基本数据类型，即T不能指定为8个基本数据类型：byte，short，int，long，float，double，char，boolean</p>
</li>
<li><p>同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型。即泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是同一类型。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Animal&lt;String&gt; sAn = <span class="keyword">new</span> Animal&lt;&gt;();<span class="comment">//指定Animal中T为String</span></span><br><span class="line">    Animal&lt;Integer&gt; iAn = <span class="keyword">new</span> Animal&lt;&gt;();<span class="comment">//指定Animal中T为Integer</span></span><br><span class="line">    System.out.println(sAn.getClass() == iAn.getClass());<span class="comment">//结果为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="从泛型类派生子类"><a href="#从泛型类派生子类" class="headerlink" title="从泛型类派生子类"></a>从泛型类派生子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：子类也是泛型类，子类的泛型标识符需要包括父类的泛型标识符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>&lt;<span class="title">T</span>,<span class="title">E</span>,...&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="comment">//情况2：子类不是泛型类，那么父类需要明确指出泛型的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">String</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ol>
<li><h4 id="泛型接口的定义语法"><a href="#泛型接口的定义语法" class="headerlink" title="泛型接口的定义语法"></a>泛型接口的定义语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称&lt;泛型标识符,泛型标识符...&gt;</span>&#123;</span><br><span class="line">    泛型标识符 方法名();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="泛型接口的实现类要求"><a href="#泛型接口的实现类要求" class="headerlink" title="泛型接口的实现类要求"></a>泛型接口的实现类要求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况1：实现类不是泛型类，接口要明确指定具体的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">parent</span>&lt;<span class="title">String</span>&gt;</span>&#123;<span class="comment">//parent指定具体数据类型为String</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：实现类也是泛型类，那么实现类的泛型标识符要包括接口的泛型标识符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ol>
<li><h4 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型标识符,泛型标识符,...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    方法体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>修饰符与返回值类型中间的&lt;泛型标识符…&gt;很重要，可以理解为声明此方法为泛型方法。同时，<strong>只有在该&lt;泛型标识符…&gt;中声明的泛型标识符，才可在方法中使用</strong>。</p>
</li>
<li><p>只有声明了&lt;泛型标识符…&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法不是泛型方法。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getName</span><span class="params">(T name)</span></span>&#123;...&#125;<span class="comment">//成员方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getName</span><span class="params">(T name)</span></span>&#123;...&#125;<span class="comment">//泛型方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getName</span><span class="params">(T name)</span></span>&#123;...&#125;<span class="comment">//静态泛型方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型类中泛型方法可以被声明为静态方法，成员方法不可以被声明为静态方法</strong></p>
</li>
<li><p>泛型类中的泛型方法是“独立的”。比如：对于泛型类使用的标识符T</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getName</span><span class="params">(T name)</span></span>&#123;...&#125;<span class="comment">//这个T和泛型类中声明的T是相互独立的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也就是说，泛型类和它里面的泛型方法使用了相同的泛型标识符的话，</span></span><br><span class="line">    <span class="comment">//可以在指定泛型类为某一种具体的数据类型的同时，</span></span><br><span class="line">    <span class="comment">//可以给泛型类中的泛型方法指定另一种具体的数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    parent&lt;Integer&gt; pa = <span class="keyword">new</span> parent&lt;&gt;();<span class="comment">//这里的T为Integer类型</span></span><br><span class="line">    pa.getName(<span class="string">"zhangsan"</span>);<span class="comment">//这里的T为String类型</span></span><br><span class="line">    <span class="comment">//上面语句是合法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="泛型方法支持可变参数"><a href="#泛型方法支持可变参数" class="headerlink" title="泛型方法支持可变参数"></a>泛型方法支持可变参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(E... es)</span></span>&#123;<span class="comment">//可变参数</span></span><br><span class="line">    <span class="keyword">for</span>(E e : es)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><ol>
<li><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ol>
<li>类型通配符一般是使用”?”代替具体的类型实参</li>
<li>所以，类型通配符是类型实参，而不是类型形参</li>
</ol>
</li>
<li><h4 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限"></a>类型通配符上限</h4><p>类/接口&lt;? extends 实参类型&gt;，泛型方法同理。要求该泛型的类型只能是实参类型或实参类型的子类类型</p>
</li>
<li><h4 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限"></a>类型通配符下限</h4><p>类/接口&lt;? super 实参类型&gt;，泛型方法同理。要求该泛型的类型只能是实参类型或实参类型的父类类型</p>
</li>
<li><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>上限：&lt;? extends T&gt; ?是T和T的子类，下限：&lt;? super T&gt; ?是T和T的父类。怎么看待这个上限和下限呢？</p>
<ul>
<li>首先应该想，其实对于Java来说 &lt;? extends T&gt;，&lt;? super T&gt; 是两个确定的类型，因为它不可能由你的赋值完了再确定吧。所以，对于&lt;? extends T&gt; 来说，集合里的元素应该是什么类型呢？应该是T类型，因为你添加的是T或者T的子类，设置为T就可以激发多态了。由此，所以你也只能从这个集合中取出T类型，因为它里面的元素本来设置的就是T类型，你赋值进去只不过是将T的子类赋值给了T，多态。<strong>但是呢，你就不能给这个集合里添加元素了，因为这个集合里元素的类型是T，假如可以添加元素，你初始化的时候初始化成T的一个子类，然后添加值的时候，却添加的另一个子类，</strong>事实上是可以添加的，因为集合元素类型是T，但里面就有了多种T的子类，这样的话，你初始化的时候是这个子类，你取出元素的时候肯定也想着取出的是可以给这个子类赋值的类型，但很有可能取出来的是T的另一个子类，你没法赋值，因为你允许添加另一个子类。<strong>所以一开始就禁止添加元素是对的。</strong></li>
<li>&lt;? super T&gt;里面的元素，应该设置为什么呢？显然应该是object，因为系统不知道你会把?当成什么，所以只能设置成object，所以你取出元素的时候，取出的是object类。<strong>可不可以添加元素呢？可以，因为下限有保证，所以可以添加T和T的子类</strong>。你初始化的时候，初始化的是T的某个父类，好了，你现在取元素，你希望取出的是你初始化的那个父类，因为你只能添加T和T的子类，所以你取出的元素，肯定可以赋值给那个父类。</li>
<li><strong>综上，&lt;? extends T&gt; 不可以添加元素，但可以取出类型为T的元素。 &lt;? super T&gt; 可以添加T或者T的子类，取出的一定是object类。</strong></li>
<li>比如方法参数为：ArrayList&lt;? extends topClass&gt; list，在方法体中list是无法add数据的。但如果方法参数是：ArrayList&lt;? super bottomClass&gt; list，那么是可以add数据的，并且可以添加bottomClass及其子类类型。</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ol>
<li><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>泛型是jdk1.5才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好的的和之前版本的代码兼容，那是因为泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为—-类型擦除。</p>
</li>
<li><h4 id="类型擦除的种类"><a href="#类型擦除的种类" class="headerlink" title="类型擦除的种类"></a>类型擦除的种类</h4><ol>
<li><h5 id="无限制类型擦除"><a href="#无限制类型擦除" class="headerlink" title="无限制类型擦除"></a>无限制类型擦除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(T key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过类型擦除之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object key;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getValue</span><span class="params">(T val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过类型擦除之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Object val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="有限制类型擦除"><a href="#有限制类型擦除" class="headerlink" title="有限制类型擦除"></a>有限制类型擦除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(T key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过类型擦除之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Number key;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Number key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">getValue</span><span class="params">(T val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过类型擦除之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">getValue</span><span class="params">(Number val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="类型擦除中的桥接方法"><a href="#类型擦除中的桥接方法" class="headerlink" title="类型擦除中的桥接方法"></a>类型擦除中的桥接方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">info</span><span class="params">(T val)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">infoImpl</span> <span class="keyword">implements</span> <span class="title">info</span>&lt;<span class="title">String</span>&gt;</span>&#123;<span class="comment">//注意这里实现类是非泛型类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过类型擦除之后</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">info</span><span class="params">(Object val)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">infoImpl</span> <span class="keyword">implements</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要我们显示的实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桥接方法，用来保持接口和类之间的实现关系</span></span><br><span class="line">    <span class="comment">//因为接口类型擦除之后，其中的方法也就随之进行类型擦除，</span></span><br><span class="line">    <span class="comment">//根据接口实现的要求，需要将接口中的所有方法实现，也就是说</span></span><br><span class="line">    <span class="comment">//接口中有Object info(Object val)方法，那我们就需要去实现它</span></span><br><span class="line">    <span class="comment">//只不过这是编译器帮我们做的，所以我们看不到</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">info</span><span class="params">(Object val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info((String)val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h3><ol>
<li><h4 id="泛型数组的创建："><a href="#泛型数组的创建：" class="headerlink" title="泛型数组的创建："></a>泛型数组的创建：</h4><ol>
<li><p>可以声明带泛型的数组引用，但是不能创建带泛型的数组对象。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] arr;<span class="comment">//是允许的</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> T[<span class="number">4</span>];<span class="comment">//是不允许的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过java.lang.reflect.Array的newInstance(Class&lt;?&gt; clazz，int length)反射创建泛型数组</p>
</li>
</ol>
</li>
<li><h4 id="一个关于泛型数组的错误使用示例"><a href="#一个关于泛型数组的错误使用示例" class="headerlink" title="一个关于泛型数组的错误使用示例"></a>一个关于泛型数组的错误使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ArrayList[] list = <span class="keyword">new</span> ArrayList[<span class="number">5</span>];<span class="comment">//创建ArrayList数组，长度为5</span></span><br><span class="line">    ArrayList&lt;String&gt;[] listArr = list;<span class="comment">//listArr引用指向list</span></span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建一个整数类型的ArrayList</span></span><br><span class="line">    inList.add(<span class="number">100</span>);<span class="comment">//为它添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    list[<span class="number">0</span>] = intList;<span class="comment">//将list[0]引用指向intList</span></span><br><span class="line">    String s = listArr[<span class="number">0</span>].get(<span class="number">0</span>);<span class="comment">//获取的时候通过listArr引用来获取</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面整个程序在运行之前一切正常，而当运行之后，会出现ClassCastException异常，即Integer无法转为String。主要就是给数组元素赋值时用的是list引用，而获取数组中元素时使用listArr引用，而两个引用的具体数据类型不同，导致出现ClassCastException。</p>
</li>
<li><h4 id="改造上面错误示例"><a href="#改造上面错误示例" class="headerlink" title="改造上面错误示例"></a>改造上面错误示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以运行示例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayList[] list = new ArrayList[5];//创建ArrayList数组，长度为5</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;String&gt;[] listArr = list;//listArr引用指向list</span></span><br><span class="line">    ArrayList&lt;String&gt;[] listArr = <span class="keyword">new</span> ArrayList[<span class="number">5</span>];<span class="comment">//在创建的时候就指定数组中每个ArrayList中的具体数据类型</span></span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建一个整数类型的ArrayList</span></span><br><span class="line">    inList.add(<span class="number">100</span>);<span class="comment">//为它添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建一个字符串类型的ArrayList</span></span><br><span class="line">    inList.add(<span class="string">"abc"</span>);<span class="comment">//为它添加一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list[0] = intList;//将list[0]引用指向intList</span></span><br><span class="line">    listArr[<span class="number">0</span>] = strList;<span class="comment">//成功</span></span><br><span class="line">    listArr[<span class="number">1</span>] = intList;<span class="comment">//在没运行之前就报错</span></span><br><span class="line">    </span><br><span class="line">    String s = listArr[<span class="number">0</span>].get(<span class="number">0</span>);<span class="comment">//获取的时候通过listArr引用来获取</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="反射构建数组"><a href="#反射构建数组" class="headerlink" title="反射构建数组"></a>反射构建数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(Class&lt;T&gt; clazz,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过Array.newInstance创建泛型数组</span></span><br><span class="line">        arr = (T[])Array.newInstance(clazz,len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给数组添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        arr[index] = T;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取数组中元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取整个数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T[] getArr()&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引总结-优化篇</title>
    <url>/2020/05/28/mysql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<ol>
<li><h3 id="MySQL优化的一般步骤"><a href="#MySQL优化的一般步骤" class="headerlink" title="MySQL优化的一般步骤"></a>MySQL优化的一般步骤</h3><ol>
<li><h4 id="通过show-status-命令了解各种sql的执行效率"><a href="#通过show-status-命令了解各种sql的执行效率" class="headerlink" title="通过show status 命令了解各种sql的执行效率"></a>通过show status 命令了解各种sql的执行效率</h4><ul>
<li>SHOW STATUS提供msyql服务器的状态信息，一般情况下，我们只需要了解以”Com”开头的指令</li>
<li>show session status like ‘Com%’；显示当前的连接的统计结果</li>
<li>show global status like ‘Com%’ ；显示自数据库上次启动至今的统计结果</li>
<li>show status like ‘Connections’；// 试图连接MySQL服务器的次数</li>
<li>show status like ‘Uptime’；//服务器工作的时间（单位秒）</li>
<li>show status like ‘Slow_queries’；//慢查询的次数 (默认是10秒中就当做是慢查询)</li>
<li>Show variables like ‘long_query_time’；//查询mysql的慢查询时间：</li>
<li>set long_query_time=2；//修改mysql 慢查询时间：如果查询时间超过2秒就算作是慢查询</li>
</ul>
<p>注：默认是session级别的，其中Com_XXX表示XXX语句所执行的次数。Com_select，Com_insert，Com_update，Com_delete通过这几个参数，可以容易地了解到当前数据库的应用是以插入更新为主还是以查询操作为主，以及各类的SQL大致的执行比例是多少。</p>
<a id="more"></a>
</li>
<li><h4 id="定位执行效率较低的SQL语句（dql出现问题的概率较dml的大）"><a href="#定位执行效率较低的SQL语句（dql出现问题的概率较dml的大）" class="headerlink" title="定位执行效率较低的SQL语句（dql出现问题的概率较dml的大）"></a>定位执行效率较低的SQL语句（dql出现问题的概率较dml的大）</h4><p>在一个项目中，找到慢查询的select语句：mysql支持把慢查询语句记录到日志文件中。程序员需要修改php.ini的配置文件，默认情况下，慢查询记录是不开启的。开启慢查询记录的方法：打开 my.ini，找到 [mysqld] 在其下面添加：long_query_time = 2和log-slow-queries = D:/mysql/logs/slow.log     #设置把日志写在那里，可以为空，系统会给一个缺省的文件，例子：我们数据表中有1千万条的数据量，DQL语句：SELECT * FROM order_copy WHERE id=12345; 查询耗时：19s &gt; 2s，所以mysql会将该条select语句记录到慢查询日志中，SELECT * FROM order_copy WHERE id=12345的执行时间：<strong>添加索引前：19s</strong>，<strong>添加索引后：0.08s</strong></p>
</li>
<li><h4 id="通过explain分析低效率的SQL语句的执行情况"><a href="#通过explain分析低效率的SQL语句的执行情况" class="headerlink" title="通过explain分析低效率的SQL语句的执行情况"></a>通过explain分析低效率的SQL语句的执行情况</h4><p>使用explain分析该dql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_copy <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure>

<p>会产生如下信息：</p>
<ul>
<li>select_type:表示查询的类型。</li>
<li>table:输出结果集的表</li>
<li>type:表示表的连接类型(system和const为佳)</li>
<li>possible_keys:表示查询时，可能使用的索引</li>
<li>key:表示实际使用的索引</li>
<li>key_len:索引字段的长度</li>
<li>rows:扫描的行数</li>
<li>Extra:执行情况的描述和说明</li>
</ul>
<p><strong>注意：要尽量避免让type的结果为all，extra的结果为：using filesort</strong></p>
</li>
<li><h4 id="确定问题并采取相应的优化措施"><a href="#确定问题并采取相应的优化措施" class="headerlink" title="确定问题并采取相应的优化措施"></a>确定问题并采取相应的优化措施</h4><p>常用的优化措施是添加索引。添加索引，我们不用加内存，不用改程序，不用调sql，只要执行个正确的’create index’，查询速度就可能提高百倍千倍。但是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的I/O。例如：给字段id添加索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> order_copy <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p>给1千万的数据添加primary key 需要耗时： 428秒（7分钟）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_copy <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure>

<p>正是因为给id添加了索引，才使得rows的结果为1，<strong>但是索引并不是可以随便添加的，以下几种情况需牢记在心：</strong></p>
<ul>
<li>较频繁的作为查询条件字段应该创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_copy <span class="keyword">WHERE</span> <span class="keyword">id</span> = $<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_copy <span class="keyword">WHERE</span> sex = <span class="string">'女'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新非常频繁的字段不适合创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_copy <span class="keyword">WHERE</span> order_state = <span class="string">'未付款'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>不会出现在WHERE子句中的字段不该创建索引</li>
</ul>
<p><strong>索引的使用</strong></p>
<ul>
<li><p>建立索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>|FULLTEXT] <span class="keyword">index</span> index_name <span class="keyword">ON</span> tbl_name (col_name [(<span class="keyword">length</span>)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>],...);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (column_list);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> talbe_name;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;//等价于第一条</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询索引(均可) </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">keys</span> <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">index</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="MySQL优化实践，其实就是要将前篇文章中的创建索引的注意点给用上"><a href="#MySQL优化实践，其实就是要将前篇文章中的创建索引的注意点给用上" class="headerlink" title="MySQL优化实践，其实就是要将前篇文章中的创建索引的注意点给用上"></a>MySQL优化实践，其实就是要将前篇文章中的创建索引的注意点给用上</h3><p><strong>一个小提示：返回表中 30% 内的数据会走索引，返回超过 30% 数据就使用全表扫描。当然这个结论太绝对了，也并不是绝对的30%，只是一个大概的范围，这个有时很重要。</strong></p>
<p>现在我们有一张user表：</p>
<ol>
<li><h4 id="如果MySQL估计使用索引比全表扫描还慢，则不会使用索引"><a href="#如果MySQL估计使用索引比全表扫描还慢，则不会使用索引" class="headerlink" title="如果MySQL估计使用索引比全表扫描还慢，则不会使用索引"></a>如果MySQL估计使用索引比全表扫描还慢，则不会使用索引</h4><p>返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。</p>
</li>
<li><h4 id="前导模糊查询查询不能命中索引"><a href="#前导模糊查询查询不能命中索引" class="headerlink" title="前导模糊查询查询不能命中索引"></a>前导模糊查询查询不能命中索引</h4><p>比如我们给user表中name字段加索引，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%s%'</span>;</span><br></pre></td></tr></table></figure>

<p>通过explain解释器发现并没有走索引，此时我们可以优化成非前导模糊查询就会走索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'s%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来"><a href="#数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来" class="headerlink" title="数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来"></a>数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来</h4><p>还是name字段加索引，name为varchar类型，那么下面这个语句不会走索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但优化成如下这个语句会走索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中复合索引"><a href="#复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中复合索引" class="headerlink" title="复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中复合索引"></a>复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中复合索引</h4><p>比如给name、age、status加复合索引，执行下面语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'user'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span>  index_name (<span class="keyword">name</span>,age,<span class="keyword">status</span>);</span><br></pre></td></tr></table></figure>

<p>下面两条语句都能命中索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'yjw'</span> <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'yjw'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：最左原则不是说查询的条件的顺序，而是查询条件中是否包含索引最左列字段</strong></p>
</li>
<li><h4 id="union、in和or都可以命中索引，推荐in"><a href="#union、in和or都可以命中索引，推荐in" class="headerlink" title="union、in和or都可以命中索引，推荐in"></a>union、in和or都可以命中索引，推荐in</h4><p>比如对status加索引后，union：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>in：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>or：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> = <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">status</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>注意：查询的CPU消耗：or &gt; in &gt; union</p>
</li>
<li><h4 id="用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到"><a href="#用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到" class="headerlink" title="用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到"></a>用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到</h4><p>假如我们给name加索引，age不加索引，然后执行下面语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'yjw'</span> <span class="keyword">OR</span> age = <span class="number">19</span>;</span><br></pre></td></tr></table></figure>

<p>因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。</p>
</li>
<li><h4 id="负向条件查询不能使用索引，可以优化为-in-查询"><a href="#负向条件查询不能使用索引，可以优化为-in-查询" class="headerlink" title="负向条件查询不能使用索引，可以优化为 in 查询"></a>负向条件查询不能使用索引，可以优化为 in 查询</h4><p>负向条件有：!=、&lt;&gt;、not in、not exists、not like等。</p>
<p>比如我们给status加索引，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> != <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">status</span> != <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>会发现并没有命中索引，但是我们可以优化为in查询，但是前提区分度要高，返回的数据的比例在30%以内。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">status</span> <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="范围查询可以命中缓存"><a href="#范围查询可以命中缓存" class="headerlink" title="范围查询可以命中缓存"></a>范围查询可以命中缓存</h4><p>范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</p>
<p>如果是范围查询和等值查询同时存在，优先匹配等值查询列的索引</p>
</li>
<li><h4 id="索引列参与计算-包括函数运算-的法则无法命中索引"><a href="#索引列参与计算-包括函数运算-的法则无法命中索引" class="headerlink" title="索引列参与计算(包括函数运算)的法则无法命中索引"></a>索引列参与计算(包括函数运算)的法则无法命中索引</h4></li>
<li><h4 id="利用覆盖索引进行查询，避免回表"><a href="#利用覆盖索引进行查询，避免回表" class="headerlink" title="利用覆盖索引进行查询，避免回表"></a>利用覆盖索引进行查询，避免回表</h4></li>
<li><h4 id="建立索引的列，不允许为-null"><a href="#建立索引的列，不允许为-null" class="headerlink" title="建立索引的列，不允许为 null"></a>建立索引的列，不允许为 null</h4><p>单列索引不存 null 值，复合索引不存全为 null 的值，如果列允许为 null，可能会得到“不符合预期”的结果集，所以，请使用 not null 约束以及默认值。</p>
<p>比如我们给一个remark字段(允许为null)加索引，执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> remark <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>发现命中索引，而执行下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> remark <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>发现没有命中索引。<strong>虽然IS NULL可以命中索引，但是NULL本身就不是一种好的数据库设计，应该使用NOT NULL 约束以及默认值</strong></p>
</li>
<li><h4 id="更新十分频繁的字段上不宜建立索引"><a href="#更新十分频繁的字段上不宜建立索引" class="headerlink" title="更新十分频繁的字段上不宜建立索引"></a>更新十分频繁的字段上不宜建立索引</h4><p>因为更新操作会变更B+树，重建索引。这个过程是十分消耗数据库性能的。</p>
</li>
<li><h4 id="区分度不大的字段上不宜建立索引"><a href="#区分度不大的字段上不宜建立索引" class="headerlink" title="区分度不大的字段上不宜建立索引"></a>区分度不大的字段上不宜建立索引</h4><p>类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引。</p>
</li>
<li><h4 id="多表关联时，要保证关联字段上一定有索引"><a href="#多表关联时，要保证关联字段上一定有索引" class="headerlink" title="多表关联时，要保证关联字段上一定有索引"></a>多表关联时，要保证关联字段上一定有索引</h4></li>
<li><h4 id="SQL语句中IN包含的值不应过多"><a href="#SQL语句中IN包含的值不应过多" class="headerlink" title="SQL语句中IN包含的值不应过多"></a>SQL语句中IN包含的值不应过多</h4><p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：<code>select id from table_name where num in(1,2,3)</code> 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。</p>
</li>
<li><h4 id="SELECT语句务必指明字段名称"><a href="#SELECT语句务必指明字段名称" class="headerlink" title="SELECT语句务必指明字段名称"></a>SELECT语句务必指明字段名称</h4><p>SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前端也需要更新。所以要求直接在select后面接上字段名。</p>
</li>
<li><h4 id="区分in和exists，-not-in和not-exists"><a href="#区分in和exists，-not-in和not-exists" class="headerlink" title="区分in和exists， not in和not exists"></a>区分in和exists， not in和not exists</h4><p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以<strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong></p>
<p>关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。<strong>如何高效的写出一个替代not exists的sql语句？</strong></p>
<p>如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> colname... <span class="keyword">FROM</span> A表 a <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> b.id <span class="keyword">FROM</span> B表 b);</span><br></pre></td></tr></table></figure>

<p>可以优化成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> colname... <span class="keyword">FROM</span> A表 a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B表 b <span class="keyword">WHERE</span> a.id = b.id;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="创建索引时避免以下错误观念"><a href="#创建索引时避免以下错误观念" class="headerlink" title="创建索引时避免以下错误观念"></a>创建索引时避免以下错误观念</h4><ul>
<li>索引越多越好，认为一个查询就需要建一个索引。</li>
<li>宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。</li>
<li>抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。</li>
<li>过早优化，在不了解系统的情况下就开始优化。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>offer</tag>
        <tag>mysql索引</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合总结</title>
    <url>/2020/05/30/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><h2 id="接口继承关系与实现"><a href="#接口继承关系与实现" class="headerlink" title="接口继承关系与实现"></a>接口继承关系与实现</h2><p><img src="https://s1.ax1x.com/2020/05/30/tQywS1.png" alt="tQywS1.png"></p>
<p>注意：java容器分为Collection和Map两大类，Map接口不是Collection的子接口。区分上图中的依赖、实现、继承各个关系。</p>
</li>
<li><h2 id="java集合思维导图"><a href="#java集合思维导图" class="headerlink" title="java集合思维导图"></a>java集合思维导图</h2><p><img src="https://s1.ax1x.com/2020/05/30/tQR7Je.png" alt="tQR7Je.png"></p>
<p>注意：上面只是展示了一个大概的集合思维导图。<a id="more"></a></p>
</li>
<li><h2 id="java集合—-Map-重点"><a href="#java集合—-Map-重点" class="headerlink" title="java集合—-Map(重点)"></a>java集合—-Map(重点)</h2><ol>
<li><h3 id="Map家族关系图"><a href="#Map家族关系图" class="headerlink" title="Map家族关系图"></a>Map家族关系图</h3><p><img src="https://s1.ax1x.com/2020/05/30/tQWT00.png" alt="tQWT00.png"></p>
</li>
<li><h3 id="HashMap-重中之重-，分1-7和1-8来看"><a href="#HashMap-重中之重-，分1-7和1-8来看" class="headerlink" title="HashMap(重中之重)，分1.7和1.8来看"></a>HashMap(重中之重)，分1.7和1.8来看</h3><ol>
<li><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><ul>
<li>1.7：Table数组+Entry链表</li>
<li>1.8：Table数组+Entry(Node)链表+红黑树</li>
</ul>
</li>
<li><h4 id="hashmap处理冲突方法-都是使用拉链法，但是有区别"><a href="#hashmap处理冲突方法-都是使用拉链法，但是有区别" class="headerlink" title="hashmap处理冲突方法-都是使用拉链法，但是有区别"></a>hashmap处理冲突方法-都是使用拉链法，但是有区别</h4><ul>
<li><p>1.7：使用头插法</p>
</li>
<li><p>1.8：使用尾插法</p>
</li>
<li><p>拉链法工作原理：</p>
<p>比如我们有下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<ol>
<li>首先创建一个hashmap，默认容量为16</li>
<li>插入&lt;K1,V1&gt;键值对，先计算K1的hashCode为115，使用除留余数法得到所在的桶下标115%16=3。</li>
<li>插入&lt;K2,V2&gt;键值对，先计算K2的hashCode为118，使用除留余数法得到所在的桶下标118%16=6。</li>
<li>插入&lt;K3,V3&gt;键值对，先计算K3的hashCode为118，使用除留余数法得到所在的桶下标118%16=6，插在&lt;K2,V2&gt;前面(<strong>头插法</strong>)。</li>
</ol>
</li>
<li><p><strong>头插法会形成环链</strong></p>
<p>假设现在是头插法有2个线程，在一个bucket上有1-&gt;2-&gt;3，线程A resize 执行遍历到了1，然后线程B执行，执行完了整个 resize，链表变成了 3-&gt;2-&gt;1。然后线程A回来继续执行，那么它在rehash 1后继续rehash 2，这时候发现2的next是1，这就形成了一个环，所以会一直循环下去直到资源耗尽。而尾插法很好的避免的这个问题，所以即使牺牲了一点点搜索的性能（也没有差很多），解决了这个多线程的问题。</p>
</li>
</ul>
</li>
<li><h4 id="hashmap查找步骤-get方法"><a href="#hashmap查找步骤-get方法" class="headerlink" title="hashmap查找步骤(get方法)"></a>hashmap查找步骤(get方法)</h4><ol>
<li><p>计算键值对所在桶下标，对key的hashCode()做hash运算，计算index</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;<span class="comment">//length为Table.length</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);<span class="comment">//为了提高效率，取模不使用%，而是与运算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中h的计算</span></span><br><span class="line"><span class="comment">//1.7进行了四次扰动</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8只进行了一次扰动</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当传入的容量值不为2的n次方时，通过这个方法将该值转为最接近它的那个2的n次方值,其中MAXIMUM_CAPACITY为2的30次方，我们假设传入cap = 14，二进制表示1110</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//n = 13,二进制表示1101</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//n = (n | n&gt;&gt;&gt;1),即n = (1101 | 0110) = 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n = (n | n&gt;&gt;&gt;1),即n = (1111 | 0011) = 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;<span class="comment">//n = (n | n&gt;&gt;&gt;1),即n = (1111 | 0000) = 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;<span class="comment">//n = (n | n&gt;&gt;&gt;1),即n = (1111 | 0000) = 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;<span class="comment">//同上</span></span><br><span class="line">    <span class="comment">//因为n是可能小于0或者大于等于最大容量值，所以需要判断，判断通过得到n+1,上述例子中n+1等于10000，即16。</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>在1.8中，为什么需要进行1次扰动(在1.7中4次扰动)：我们对key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致我们所生成的下标值不能够完全散列，为了解决这个问题将生成的hashcode值的高16位和低16位进行异或运算，这样得到的值再进行相与，得到最散列的下标值。<strong>总的来说就是让高16位有机会参与决定hash的值</strong>。</li>
<li>需要保证Table数组的长度为2的n次方，只有这样，n-1才能够达到最大的n-1值。反证：如果length = 15，那么length - 1 = 14，用二进制表示为1110，进行相与的时候，最后一位总为0，这样Table数组总会有些桶下标无法通过取模得到，从而导致这些空间被浪费掉。<strong>总的来说就是为了数据均匀分布。</strong></li>
</ol>
</li>
<li><p>如果在bucket(桶)⾥的第⼀个节点直接命中，则直接返回；</p>
</li>
<li><p>如果有冲突，则通过key.equals(k)去查找对应的Entry;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明：两个对象相等，hashcode一定相等</span></span><br><span class="line"><span class="comment">	 两个对象不等，hashcode不一定不等</span></span><br><span class="line"><span class="comment">	 hashcode相等，两个对象不一定相等</span></span><br><span class="line"><span class="comment">	 hashcode不等，两个对象一定不等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;<span class="comment">//重写hashCode方法</span></span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//重写equals方法</span></span><br><span class="line">        <span class="comment">//此处单独比较的是Node</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">         Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">       <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">         Objects.equals(value, e.getValue()))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.8 getNode源码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 判断表是否为空，表长度是否大于零，并且根据此key对应的表内是否存在Node节点。   </span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    	(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     	<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">    		((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="comment">// 检查第一个Node节点，若是命中则不需要进行do... while循环。</span></span><br><span class="line">           <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//树形结构，采用对应的检索方法，进行检索。</span></span><br><span class="line">             	<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        	<span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表方法做while循环，使用equals进行判断，直到命中结束或者遍历结束。</span></span><br><span class="line">        		<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        			((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             		<span class="keyword">return</span> e;</span><br><span class="line">        	&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li>
<li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="hashmap插入-jdk-1-8-putVal方法"><a href="#hashmap插入-jdk-1-8-putVal方法" class="headerlink" title="hashmap插入(jdk 1.8 putVal方法)"></a>hashmap插入(jdk 1.8 putVal方法)</h4><ol>
<li><p>对key的hashCode()做hash运算，计算index(原理同get方法)</p>
</li>
<li><p>如果没碰撞直接放到bucket⾥</p>
</li>
<li><p>如果碰撞了，以链表的形式存在buckets后</p>
</li>
<li><p>如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)</p>
</li>
<li><p>如果节点已经存在就替换old value(保证key的唯⼀性)</p>
</li>
<li><p>如果bucket达到阈值(超过load factor*current capacity)，就要resize</p>
</li>
<li><p>在得到下标值以后，可以开始put值进入到数组+链表中，会有三种情况：</p>
<ol>
<li>数组的位置为空</li>
<li>数组的位置不为空，且下面是链表的格式</li>
<li>数组的位置不为空，且下面是红黑树的格式</li>
</ol>
</li>
<li><p>同时，对于key和value也要经历以下步骤：</p>
<ol>
<li>通过key的散列获取到对应的桶下标</li>
<li>遍历该桶下的Node节点，做更新/插入操作</li>
<li>扩容检测</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// HashMap的懒加载策略，当执行put操作时检测Table数组初始化。</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//获取到对应的bucket下标，如果当前bucket为空，则直接初始化一个新的Node并放入该bucket中。</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//进行值的判断：判断是不是对于相同的key值传进来不同的value，若是如此，将原来的value进行返回</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line"><span class="comment">//如果当前Node类型为TreeNode，调用PutTreeVal方法。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//如果不是TreeNode，则就是链表，遍历并与输入key做命中碰撞。</span></span><br><span class="line">           <span class="keyword">else</span> &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">//如果当前Table中不存在当前key，则添加。</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//超过了TREEIFY_THRESHOLD则转化为红黑树。</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                       	  treeifyBin(tab, hash);</span><br><span class="line">                       	  <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="comment">//做命中碰撞，使用hash、内存和equals同时判断（不同的元素hash可能会一致）。</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))   </span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//如果命中不为空，更新操作。</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	   <span class="comment">//只有当hashmap结构发生改变才改变modCount值，更新不算    </span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       <span class="comment">//扩容检测！</span></span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="hashmap扩容-resize方法，jdk-1-8"><a href="#hashmap扩容-resize方法，jdk-1-8" class="headerlink" title="hashmap扩容(resize方法，jdk  1.8)"></a>hashmap扩容(resize方法，jdk  1.8)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//先将老的Table取别名，这样利于后面的操作。</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示之前的数组容量不为空。</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时的数组容量大于最大值</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 扩容阙值为Int类型的最大值，这种情况很少出现</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//表示old数组的长度没有那么大，进行扩容，两倍（这里也是有讲究的）对阙值也进行扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示之前的容量是0但是之前的阙值却大于零，此时新的hash表长度等于此时的阙值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//表示是初始化时候，采用默认的数组长度 * 负载因子</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时表示若新的阙值为0 就得用新容量 * 加载因子重新进行计算。</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始对新的hash表进行相对应的操作。</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧的hash表，将之内的元素移到新的hash表中。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap ; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//表示这个bucket不为空</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 表示当前只有一个元素，重新做hash散列并赋值计算。</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果在旧哈希表中，这个位置是树形的结果，就要把新hash表中也变成树形结构，</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//如果是链表</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;<span class="comment">// 遍历当前Table内的Node赋值给新的Table。</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 原地不动的数据</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 需要迁移的数据</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 原索引放到bucket里面</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap放到bucket里面</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为扩容需要将所有的旧数据都进行遍历，所以这是个很费时间的操作。</p>
<p>一些其他的hash算法：MurmurHash、MD4、MD5。看看String中hashCode的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h = hash;</span><br><span class="line">	<span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">char</span> val[] = value;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        	h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">    	hash = h;</span><br><span class="line">   	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在String类中有个私有实例字段hash表示该串的哈希值，在第一次调用hashCode方法时，字符串的哈希值被计算并且赋值给hash字段，之后再调用hashCode方法便可以直接取hash字段返回。</p>
<p>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</p>
<p>哈希计算公式可以计为s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]，取31为权主要是因为31是一个奇质数，所以31*i=32*i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多</p>
</li>
<li><h4 id="hashmap在jdk-1-8的改动"><a href="#hashmap在jdk-1-8的改动" class="headerlink" title="hashmap在jdk 1.8的改动"></a>hashmap在jdk 1.8的改动</h4><ol>
<li>存储结构增加了红黑树</li>
<li>优化了高位运算的hash函数算法：h^(h&gt;&gt;&gt;16)，只进行一次扰动</li>
<li>使用尾插法，扩容后元素要么在原地，要么是在原位置上移动oldCap个位置，解决了环链问题</li>
</ol>
</li>
<li><h4 id="hashmap的多线程不安全问题"><a href="#hashmap的多线程不安全问题" class="headerlink" title="hashmap的多线程不安全问题"></a>hashmap的多线程不安全问题</h4><ol>
<li>jdk 1.7使用头插法容易产生环链，<a href="#hashmap处理冲突方法-都是使用拉链法，但是有区别">前面</a>已经说过</li>
<li>前后数据的不一致性，比如前一个put的数据与后来get该数据不一致</li>
</ol>
</li>
<li><h4 id="hashmap多线程不安全问题解决方案"><a href="#hashmap多线程不安全问题解决方案" class="headerlink" title="hashmap多线程不安全问题解决方案"></a>hashmap多线程不安全问题解决方案</h4><ol>
<li><p>hashTable：Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，因为给每个方法都加了synchronized，相当于锁住了整个hashmap，所以任一时间只有一个线程能写Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<p>和hashmap的比较：</p>
<ol>
<li>hashtable使用synchronized进行同步</li>
<li>hashmap键值都可以为null，key为null时放在Table[0]处</li>
<li>hashmap是快速失败（<a href="#fail-fast迭代器和fail-safe迭代器">fail-fast迭代器</a>）</li>
<li>hashmap不能保证随着时间推移Map中的元素次序不变</li>
</ol>
</li>
<li><p>可以用 Collections 的 synchronizedMap 方法使HashMap具有线程安全的能力。</p>
</li>
<li><p><strong>concurrentHashMap：</strong></p>
<ol>
<li>ConcurrentHashMap和HashMap实现上类似，最主要的区别是ConcurrentHashMap采用了分段锁(Segment)，每个分段锁维护着几个桶(HashEntry)，多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高(并发度就是Segment的个数，默认是16)。</li>
<li>Segment继承自ReentrantLock。</li>
<li>每个Segment维护了一个count变量来统计该Segment中的键值对个数，在执行size操作时，需要遍历所有Segment然后把count累计起来。</li>
<li>ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。尝试次数使用RETRIES_BEFORE_LOCK定义，该值为2，retries 初始值为-1，因此尝试次数为3。如果尝试的次数超过3次，就需要对每个Segment加锁。</li>
<li>JDK1.7使用分段锁机制来实现并发更新操作，核心类为Segment，它继承自重入锁ReentrantLock，并发度与Segment数量相等。JDK 1.8使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized，并且 JDK 1.8的实现也在链表过长时会转换为红黑树</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="fail-fast迭代器和fail-safe迭代器"><a href="#fail-fast迭代器和fail-safe迭代器" class="headerlink" title="fail-fast迭代器和fail-safe迭代器"></a>fail-fast迭代器和fail-safe迭代器</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。</p>
<ol>
<li><p>快速失败(fail-fast):</p>
<p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>注意：这里异常的抛出条件是检测到modCount !=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
</li>
<li><p>安全失败(fail-safe):</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
</li>
</ol>
</li>
<li><h4 id="链表转红黑树阈值为8，红黑树转链表阈值为6"><a href="#链表转红黑树阈值为8，红黑树转链表阈值为6" class="headerlink" title="链表转红黑树阈值为8，红黑树转链表阈值为6"></a>链表转红黑树阈值为8，红黑树转链表阈值为6</h4><ol>
<li>TREEIFY_THRESHOLD链表树化阙值： 默认值为8。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</li>
<li>UNTREEIFY_THRESHOLD红黑树链化阙值： 默认值为6。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</li>
<li>因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。所以不应该一开始就使用红黑树。</li>
<li>设置为6的时候退转为链表。中间有个差值7可以防⽌链表和树之间频繁的转换。<br>假设⼀下，如果设计成链表个数超过8则链表转换成树结构，链表个数⼩于8则树结构转换成链表，那么如果⼀个HashMap不停的插⼊、删除元素，链表个数在8左右徘徊，就会频繁的发⽣树转链表、链表转树，效率会很低。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="java集合—-List"><a href="#java集合—-List" class="headerlink" title="java集合—-List"></a>java集合—-List</h2><ol>
<li><h3 id="List家族关系图"><a href="#List家族关系图" class="headerlink" title="List家族关系图"></a>List家族关系图</h3><p><img src="https://s1.ax1x.com/2020/06/01/tG6uJU.png" alt="tG6uJU.png"></p>
</li>
<li><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li><h4 id="ArrayList-是最常用的-List-实现类，内部是通过数组实现的"><a href="#ArrayList-是最常用的-List-实现类，内部是通过数组实现的" class="headerlink" title="ArrayList 是最常用的 List 实现类，内部是通过数组实现的"></a>ArrayList 是最常用的 List 实现类，内部是通过数组实现的</h4><p>它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p>
</li>
<li><h4 id="数组的默认大小为10"><a href="#数组的默认大小为10" class="headerlink" title="数组的默认大小为10"></a>数组的默认大小为10</h4><p>添加元素时使用ensureCapacityInternal()方法来保证容量足够，如果不够时，需要使用grow()方法进行扩容，新容量的大小为oldCapacity + (oldCapacity &gt;&gt; 1)，也就是<strong>旧容量的 1.5 倍</strong>。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
</li>
<li><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 <strong>transient</strong> 修饰，<strong>该关键字声明数组默认不会被序列化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol>
<li><h4 id="Vector-与-ArrayList-一样，也是通过数组实现的"><a href="#Vector-与-ArrayList-一样，也是通过数组实现的" class="headerlink" title="Vector 与 ArrayList 一样，也是通过数组实现的"></a>Vector 与 ArrayList 一样，也是通过数组实现的</h4><p>不同的是它使用了 synchronized 进行线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p>
</li>
<li><h4 id="Vector扩容"><a href="#Vector扩容" class="headerlink" title="Vector扩容"></a>Vector扩容</h4><p>Vector 的构造函数可以传入capacityIncrement参数，它的作用是在扩容时使容量capacity增长capacityIncrement。如果这个参数的值<strong>小于等于 0，扩容时每次都令 capacity 为原来的两倍</strong>。</p>
<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
</li>
<li><h4 id="与ArrayList的比较"><a href="#与ArrayList的比较" class="headerlink" title="与ArrayList的比较"></a>与ArrayList的比较</h4><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</li>
</ul>
</li>
<li><h4 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h4><ul>
<li><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>CopyOnWriteArrayList</p>
<ol>
<li><p>读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。</p>
</li>
<li><p>适用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList <strong>不适合内存敏感以及对实时性要求很高的场景</strong>。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol>
<li><h4 id="基于双向链表实现"><a href="#基于双向链表实现" class="headerlink" title="基于双向链表实现"></a>基于双向链表实现</h4><p>只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
<li><h4 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h4><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
</li>
<li><h4 id="LinkedList是线程不安全的"><a href="#LinkedList是线程不安全的" class="headerlink" title="LinkedList是线程不安全的"></a>LinkedList是线程不安全的</h4></li>
</ol>
</li>
</ol>
</li>
<li><h2 id="java集合—-Set"><a href="#java集合—-Set" class="headerlink" title="java集合—-Set"></a>java集合—-Set</h2><p><strong>Set 注重独一无二的性质</strong>，可以利用该特性去重，该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值(java 是依据对象的内存地址计算出的此序号)判断的，如果想要让两个不同的对象视为相等的，<strong>就必须覆盖 Object 的 hashCode 方法和 equals 方法。</strong></p>
<ol>
<li><h3 id="Set家族关系图"><a href="#Set家族关系图" class="headerlink" title="Set家族关系图"></a>Set家族关系图</h3><p><img src="https://s1.ax1x.com/2020/06/01/tGo4eS.png" alt="tGo4eS.png"></p>
</li>
<li><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol>
<li><h4 id="基于哈希表实现"><a href="#基于哈希表实现" class="headerlink" title="基于哈希表实现"></a>基于哈希表实现</h4><p><strong>支持快速查找，但不支持有序性操作</strong>。并且失去了元素的插入顺序信息，也就是说使用Iterator遍历HashSet得到的结果是不确定的。</p>
</li>
<li><h4 id="存储与查找"><a href="#存储与查找" class="headerlink" title="存储与查找"></a>存储与查找</h4><p>哈希表边存放的是哈希值HashSet存储元素的顺序并不是按照存入时的顺序(和 List 显然不同)而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法如果equls结果为true，HashSet就视为同一个元素。如果equals为false就不是同一个元素。</p>
<p>哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延(可以认为哈希值相同的元素放在一个哈希桶中)。也就是哈希一样的存一列。<strong>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</strong></p>
</li>
</ol>
</li>
<li><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol>
<li><h4 id="基于红黑树实现"><a href="#基于红黑树实现" class="headerlink" title="基于红黑树实现"></a>基于红黑树实现</h4><p>支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，<strong>HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</strong></p>
</li>
<li><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而<strong>自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</strong></li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。<strong>如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>具有 HashSet 的查找效率，并且<strong>内部使用双向链表维护元素的插入顺序</strong>。</p>
<ol>
<li><h4 id="对于-LinkedHashSet-而言，它继承于-HashSet、又基于-LinkedHashMap-来实现的"><a href="#对于-LinkedHashSet-而言，它继承于-HashSet、又基于-LinkedHashMap-来实现的" class="headerlink" title="对于 LinkedHashSet 而言，它继承于 HashSet、又基于 LinkedHashMap 来实现的"></a>对于 LinkedHashSet 而言，它继承于 HashSet、又基于 LinkedHashMap 来实现的</h4><p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端基础</category>
      </categories>
      <tags>
        <tag>offer</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引总结-基础原理篇</title>
    <url>/2020/05/26/mysql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<ol>
<li><h3 id="MySQL索引本质"><a href="#MySQL索引本质" class="headerlink" title="MySQL索引本质"></a>MySQL索引本质</h3><p>是一种用来帮助mysql高速获取排好序的数据的<strong>数据结构</strong>。</p>
</li>
</ol>
<ol start="2">
<li><h3 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h3><ol>
<li><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol>
<li>从存储结构上来划分：BTree索引(B-Tree或B+Tree索引)，Hash索引，full-index全文索引，R-Tree索引。</li>
<li>从应用层次来分：普通索引，唯一索引，复合索引，主键索引</li>
<li>根据数据的物理顺序与键值的逻辑(索引)顺序关系：聚集索引，非聚集索引。</li>
</ol>
<a id="more"></a>

<blockquote>
<p>注意：</p>
<p>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值，即一个索引只包含单个列，一个表可以有多个单列索引，叶节点包含了主键(注意不是记录所在硬盘的地址)，因此有个回表的概念：即普通索引中先找到我们需要的数据的主键，然后再在表中进行一次查询，myISAM是典型的一种需要”回表查询”的引擎。</p>
<p><strong>回表：</strong>当对一个列创建索引之后，索引会包含该列的键值及键值对应行所在的 rowid。通过索引中记录的 rowid 访问表中的数据就叫回表。回表次数太多会严重影响 SQL 性能，如果回表次数太多，就不应该走索引扫描，应该直接走全表扫描。</p>
<p><strong>EXPLAIN命令结果中的<code>Using Index</code>意味着不会回表，通过索引就可以获得主要的数据。<code>Using Where</code>则意味着需要回表取数据。</strong></p>
<p>额外说一句mysql中主要文件结构，我们主要比较myISAM和InnoDB(后文还会提到)：</p>
<p>mysql中所有的表存储在mysql目录/data目录下</p>
<p>对于使用myISAM引擎的表：.frm是表结构文件，.MYD是表记录文件，.MYI是表索引记录文件</p>
<p>而对于使用innoDB引擎的表：.frm是表结构文件，.ibd是表记录和索引文件</p>
<p>由上可知，myISAM索引文件和数据文件是分离的（非聚集），所以查询是先从.MYI文件中查找索引(如果有的话),然后根据索引查询表记录所在磁盘地址。innoDB索引文件和数据文件是在一起的（聚集），所以查询是直接在.ibd文件中查询索引(如果有的话)，而叶子节点存储着表记录，所以查询到索引即查询到表记录</p>
<p>然后，再由上我们可以知道：InnoDB一定要有主键，因为InnoDB是默认用B+tree数据结构来组织数据记录的，所以如果不设置主键的话，数据就无法进行组织存储。当然InnoDB会自动选一个可以用来唯一标识一张表中所有记录的字段（简单说就是该字段所有记录不重复）来做主键索引字段，如果找不到这样的字段，就会自动生成一个这样的字段用作唯一索引字段row_id</p>
<p>唯一索引：索引列的值必须唯一，但允许有空值，一个表允许多个列创建唯一索引。</p>
<p>主键索引：数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p>复合索引：即一个索引包含多一个列</p>
<p>聚集索引：并不是一种单独的索引类型，而是一种数据存储方式，也可以说叶节点包含了完整的数据记录。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行</p>
<p>非聚集索引：不是聚集索引就是非聚集索引(^_^)，当然了，前面有说过，数据和索引不是在一起存储的可以看做非聚集索引。</p>
<p><strong>注意区分主键和索引的区别：</strong></p>
<p>​    定义：</p>
<p>​    主键：唯一标识一条记录，不能有重复的，不允许为空</p>
<p>​    外键：表的外键是另一表的主键, 外键可以有重复的, 可以是空值</p>
<p>​    索引：是对数据库表中一列或多列的值进行排序的一种结构</p>
<p>​    作用：</p>
<p>​    主键：用来保证数据完整性</p>
<p>​    外键：用来和其他表建立联系用的</p>
<p>​    索引：是提高查询排序的速度</p>
<p>​    个数：</p>
<p>​    主键：主键只能有一个</p>
<p>​    外键：一个表可以有多个外键</p>
<p>​    索引：一个表可以有多个唯一索引</p>
<p>​    添加：</p>
<p>​    主键：ALTER TABLE “表名” ADD PRIMARY KEY (字段名)</p>
<p>​    外键：ALTER TABLE “表名” ADD FOREIGN KEY (字段名) REFERENCES “另一张表名”( 字段名)</p>
<p>​    索引：ALTER TABLE “表名” ADD INDEX (字段名)</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><h4 id="各个索引比较"><a href="#各个索引比较" class="headerlink" title="各个索引比较"></a>各个索引比较</h4><p>​    0x01. 默认不使用二叉查找树的原因:比如给col列加索引，而col列分别为1，2，3，4，5，6，根据二叉查找树的特点，最终索引将会变成只有右子树形状的二叉树，而这时进行查询的效果就和链表一样了，所以不适用</p>
<p>​    0x02. 默认不使用红黑树的原因:当数据很大(上百万上千万)时树的高度就比较高，假如我们需要的数值位于叶子节点，那么需要进行的磁盘i/o就比较多(比如树高5，则至少要进行5次磁盘i/o)，而进行磁盘i/o会让效率降低，因为其需要很多的时间</p>
<p>​    0x03. 默认不使用hash表的原因:1.不支持范围查询。2.不支持排序，也不支持模糊查询以及多列索引的最左前缀匹配。3.当数据量上去了之后，hash冲突的概率也会变大，效率将会明细降低。4.hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。5.hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
<p>​    0x04. b+tree是btree的变种：1.非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引。2.叶子节点包含所有索引字段与data。3.叶子节点用双向指针相连，提高区间访问的性能。很明显非叶子节点不存data之后就可以存储更多的索引，从而可以让树的高度更小，同时叶子节点加了指针相连之后，可以很好的支持范围查找</p>
<p>​    0x05. b树也有好处：B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<blockquote>
<p>注意：</p>
<p>通过上面的比较我们可以知道：</p>
<ol>
<li>节点中(数据)索引占用空间越小，那么该节点中数据(索引)的数量就越多，从而数的高度越低，从而IO次数更少。所以一般推荐整型主键做索引，因为这样不仅比较更快，同时占用的空间也小。同时这也是为什么b+tree要求把真正的数据记录放到叶子节点而不是内层节点的原因，因为一旦放到内层节点，那么每个节点中能保存索引的个数会大幅度下降，导致树增高。当每个节点中(数据)索引个数为1时会退化成线性表。</li>
<li>最左匹配原则(这里只做一个通俗理解，后面文章还会提到)：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li>
</ol>
</blockquote>
</li>
</ol>
<ol start="3">
<li><h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><ol>
<li><h4 id="myISAM索引实现"><a href="#myISAM索引实现" class="headerlink" title="myISAM索引实现"></a>myISAM索引实现</h4><p>myISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是<strong>数据记录的地址</strong>。下图是myISAM索引的原理图：</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tEDrtg.png" alt="tEDrtg.png"></p>
<p>这里设表共有三列，假设我们以Col1为主键，则上图便是一个myISAM表的主索引示意图。可以看出myISAM的索引文件仅仅保存数据记录的地址。<strong>在myISAM中</strong>，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tE6W24.png" alt="tE6W24.png"></p>
<p>同样也是一棵B+Tree，data域保存数据记录的地址。因此，myISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p><strong>myISAM的索引是非聚集索引。</strong></p>
</li>
<li><h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>InnoDB索引实现可以和myISAM对比来看。</p>
<p>1）第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。如图：</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tE2UPK.png" alt="tE2UPK.png"></p>
</li>
</ol>
<p>​        上图是Innodb主索引(同时也是数据文件)的示意图，可以看到可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键(MyISAM可以没有)，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>​    2）第二个与myISAM索引不同的是InnoDB的辅助索引data域存储的是相应记录的主键而不是记录地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引:</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tE469x.png" alt="tE469x.png"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</li>
<li><h3 id="myISAM和innoDB的区别与选择："><a href="#myISAM和innoDB的区别与选择：" class="headerlink" title="myISAM和innoDB的区别与选择："></a>myISAM和innoDB的区别与选择：</h3><ol>
<li><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4></li>
</ol>
<p>​    1）InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
<p>​    2）InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
<p>​    3）InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必    须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。    因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索    引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p>
<p>​    4）InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
<p>​    5）InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
<ol start="2">
<li><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>1）是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p>
<p>2）如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p>
<p>3）系统崩溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p>
<p>4）MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p>
</li>
</ol>
</li>
<li><h3 id="建立一个合适索引-为后面索引优化做一个抛砖引玉"><a href="#建立一个合适索引-为后面索引优化做一个抛砖引玉" class="headerlink" title="建立一个合适索引(为后面索引优化做一个抛砖引玉)"></a>建立一个合适索引(为后面索引优化做一个抛砖引玉)</h3><ol>
<li><h4 id="建立索引的原理"><a href="#建立索引的原理" class="headerlink" title="建立索引的原理"></a>建立索引的原理</h4><p>一个最重要的原则是最左前缀原理，在提这个之前要先说下联合索引，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为1的特例。</p>
<p>索引匹配的最左原则具体是说，假如索引列分别为A，B，C，顺序也是A，B，C：</p>
<ul>
<li>那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询</li>
<li>如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引</li>
<li>如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了</li>
<li>如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引</li>
</ul>
<p>因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担(要维护索引数据结构)，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p>
<p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>InnoDB使用聚集索引，数据记录本身被存于主索引(一颗B+Tree)的叶子节点上。这就要求同一个叶子节点内(大小为一个内存页或磁盘页)的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子(InnoDB默认为15/16)，则开辟一个新的页(节点)。如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下：</p>
<p><img src="https://s1.ax1x.com/2020/05/28/tVfght.gif" alt="tVfght.gif"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，如下<strong>(注意D080的位置)</strong>：</p>
<p><img src="https://s1.ax1x.com/2020/05/28/tVhKUA.gif" alt="tVhKUA.gif"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>页分裂：如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的。</p>
</li>
<li><h4 id="建立索引的一些注意点"><a href="#建立索引的一些注意点" class="headerlink" title="建立索引的一些注意点"></a>建立索引的一些注意点</h4><ol>
<li><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。where子句中使用最频繁的一列放在最左边。</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
<li><p>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键(索引)的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p>
</li>
<li><p>索引列不能参与计算和函数运算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可，当然要考虑原有数据和线上使用情况</p>
</li>
<li><p>主键不推荐有业务含义：(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</p>
</li>
<li><p>较频繁作为查询条件的字段才去创建索引，更新频繁字段不适合创建索引</p>
</li>
<li><p>定义有外键的数据列一定要建立索引</p>
</li>
<li><p>索引字段越小越好，为较长的字符串使用前缀索引，当然前提是前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>[^前缀索引：如果索引列长度过长，这种列索引时将会产生很大的索引文件，不便于操作，可以使用前缀索引方式进行索引前缀索引应该控制在一个合适的点，控制在0.31黄金值即可（大于这个值就可以创建）。SELECT COUNT(DISTINCT(LEFT(<code>title</code>,10)))/COUNT(*) FROM Arctic; — 这个值大于0.31就可以创建前缀索引，Distinct去重复 ALTER TABLE <code>user</code> ADD INDEX <code>uname</code>(title(10)); — 增加前缀索引SQL，将人名的索引建立在10，这样可以减少索引文件大小，加快索引查询速度。]: </p>
</li>
<li><p>使用组合索引，可以减少文件索引大小，在使用时速度要优于多个单列索引</p>
</li>
<li><p>不要过多创建索引，除了增加额外的磁盘空间外，对于DML操作的速度影响很大，因为其每增删改一次就得从新建立索引</p>
</li>
<li><p>数字和字符串比较不会使用索引，前缀模糊查询不走索引(如select * from table_name where name like ‘%jack’;)</p>
</li>
<li><p>应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
</li>
<li><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<p>​    1. 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</p>
<p>​    2. 基于非唯一性索引的检索</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>offer</tag>
        <tag>mysql索引</tag>
      </tags>
  </entry>
  <entry>
    <title>懒人的项目Demo</title>
    <url>/2020/06/25/%E6%87%92%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AEDemo/</url>
    <content><![CDATA[<h2 id="lazywork"><a href="#lazywork" class="headerlink" title="lazywork"></a>lazywork</h2><p><a href="https://github.com/VampireSmile/lazywork" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/VampireSmile/lazywork</a></p>
<ol>
<li><h3 id="基础的CRUD"><a href="#基础的CRUD" class="headerlink" title="基础的CRUD"></a>基础的CRUD</h3><ul>
<li>使用ajax+ssm框架利用Maven构建一个简单的CRUD小Demo</li>
<li>开发测试环境：Windows_10(google_81 + IDEA2019_3.2 + Tomcat_9) + CentOS_7(mysql_5.7)。</li>
<li>注意：Demo是使用mybatis的逆向工程生成的bean实体类、dao接口类、以及mybatis的mapper文件。其次，如果有需要，首先根据resources目录下的sql文件建好表，同时需要更改dp.properties中的mysql所在服务器的地址</li>
<li>Demo地址：<a href="https://github.com/VampireSmile/lazywork/tree/master/base_ssm_crud" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/VampireSmile/lazywork/tree/master/base_ssm_crud</a></li>
</ul>
<a id="more"></a>
</li>
<li><h3 id="学生人脸识别考勤App"><a href="#学生人脸识别考勤App" class="headerlink" title="学生人脸识别考勤App"></a>学生人脸识别考勤App</h3><ul>
<li>一个简单的app，后台使用简单的servlet，手机客户端调用的是虹软的人脸识别sdk和高德地图的定位sdk，通过手机客户端与web服务器端之间的人脸特征数据交互最终达到一个实现人脸一对一比对的效果。</li>
<li>开发测试环境：Windows(androidStudio_3.5（手机端） + eclipseJavaEE（web端） + Tomcat_9 ) +  CentOS_7（mysql_5.7.25） + Honor Play_COR-AL10_9</li>
<li>注意：<ol start="0">
<li>因为这是我只花了一周时间做的人脸识别考勤课设题目，后台只是使用了简单的Servlet，所以很多地方比较草率，比较僵硬，如果测试至少需要两台手机(一台模拟老师，一台模拟学生)</li>
<li>因为我这是直接在虹软的官方demo上参照其官方文档进行修改，所以demo中SingleImageActivity和FaceAttrPreviewActivity已被修改，没带Activity后缀的是我添加的，如果要查看虹软官方原始的人脸识别demo请去官方查看下载</li>
<li>项目中两个SDK(虹软和高德)的appid和sdkid分别是我在虹软平台和高德地图平台申请的，如有需要请自行申请，修改即可(虹软是在common.Constants下，高德是在清单文件中)</li>
<li>如果服务器和数据库都已准备好，可以在局域网下通信(可以将手机，服务器和mysql所在机器连接到同一wifi测试)</li>
</ol>
</li>
<li>项目地址：<a href="https://github.com/VampireSmile/lazywork/tree/master/ArcSoft_ArcFace_Android_V3.0" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/VampireSmile/lazywork/tree/master/ArcSoft_ArcFace_Android_V3.0</a></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>lazywork</category>
        <category>demo</category>
      </categories>
      <tags>
        <tag>lazywork</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>日常问题记录</title>
    <url>/2020/05/31/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li><h4 id="解决VMware网络问题的方法："><a href="#解决VMware网络问题的方法：" class="headerlink" title="解决VMware网络问题的方法："></a>解决VMware网络问题的方法：</h4><p>管理员身份运行cmd -&gt; 输入 netsh winsock reset -&gt; 重启电脑 同时也是windows修复网络问题的一种方法</p>
</li>
<li><h4 id="解决spring中tx报错问题："><a href="#解决spring中tx报错问题：" class="headerlink" title="解决spring中tx报错问题："></a>解决spring中tx报错问题：</h4><p>在设置xml catalog 时要把key改成<a href="http://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank" rel="external nofollow noopener noreferrer">http://www.springframework.org/schema/tx/spring-tx.xsd</a></p>
</li>
<li><h4 id="解决jsp链接数据库中文乱码问题："><a href="#解决jsp链接数据库中文乱码问题：" class="headerlink" title="解决jsp链接数据库中文乱码问题："></a>解决jsp链接数据库中文乱码问题：</h4><ul>
<li>首先在mysql端使用show variables like ‘%char%；然后把所有都设置为utf-8（反正要一致)，修改/etc/my.cnf(centOS7)中设置default为utf-8；</li>
<li>然后jsp也面中如果是post传输参数，则需要先设置request.setCharacterEncoding=utf-8,如果是get传输就在链接mysql的url后面加useUnicode=true&amp;characterEncoding(“utf-8”);</li>
</ul>
</li>
<li><h4 id="html中的一个布局问题："><a href="#html中的一个布局问题：" class="headerlink" title="html中的一个布局问题："></a>html中的一个布局问题：</h4><p>div:overflow属性：设置div滚动条；z-index属性：值越大表示显示在上面，在div覆盖时（如二级导航）有用，但要设置position：relative</p>
</li>
<li><h4 id="在学校用android-studio下载sdk时问题："><a href="#在学校用android-studio下载sdk时问题：" class="headerlink" title="在学校用android studio下载sdk时问题："></a>在学校用android studio下载sdk时问题：</h4><p>只能用手机热点，无法用校园网（原因未知）,或者修改host文件C:/windows/system32/drivers/etc/hosts<br>如：203.208.41.174   dl.google.com</p>
</li>
<li><h4 id="android-studio-5037端口被占用-Unable-to-connect-to-adb-daemon-on-port-5037-："><a href="#android-studio-5037端口被占用-Unable-to-connect-to-adb-daemon-on-port-5037-：" class="headerlink" title="android studio 5037端口被占用(Unable to connect to adb daemon on port: 5037)："></a>android studio 5037端口被占用(Unable to connect to adb daemon on port: 5037)：</h4><p>修改5037端口：环境变量-&gt;新建-&gt;变量名：ANDRIOD_ADB_SERVER_PORT-&gt;变量值：设置在65535之内的有效没被占用的端口号</p>
</li>
<li><h4 id="今日升级为win10后，之前安装的VMware不兼容："><a href="#今日升级为win10后，之前安装的VMware不兼容：" class="headerlink" title="今日升级为win10后，之前安装的VMware不兼容："></a>今日升级为win10后，之前安装的VMware不兼容：</h4><p>把之前创建的虚拟机文件备份，重新安装Vmware，再导入这些文件。但之后需要重置虚拟网络适配器：还原默认设置，如果不还原的话会产生诸如ping不通的问题，个人认为可能是电脑升级连带着虚拟网络适配器的ip和DHCP改变了，所以如果不还原手改的话需要改很多地方，最简单的就是直接点还原默认设置，虚拟机会给我们自动搞定之后的一切。重置也可以解决物理机ping不通虚拟机的问题</p>
</li>
<li><h4 id="删除Xftp和Xshell之后总是弹出Windows-installar："><a href="#删除Xftp和Xshell之后总是弹出Windows-installar：" class="headerlink" title="删除Xftp和Xshell之后总是弹出Windows installar："></a>删除Xftp和Xshell之后总是弹出Windows installar：</h4><ul>
<li>原因：注册表没删干净</li>
<li>解决办法：cmd-&gt;regedit-&gt;搜索注册表-&gt;Xftp，XShell，Xshell，netSarang，Netsarang，NetSarang将搜到的所有关于Xftp，Xshell的注册表项都删除才算删干净-&gt;重启</li>
</ul>
</li>
<li><h4 id="android地图软件打包之后获取不到地图信息"><a href="#android地图软件打包之后获取不到地图信息" class="headerlink" title="android地图软件打包之后获取不到地图信息"></a>android地图软件打包之后获取不到地图信息</h4><p>原因：发布SHA1和调试SHA1设置不一致<br>   方式一 ：</p>
<pre><code>打开你Android studio底部的terminal 执行keytool -v -list -keystore +签名文件路径+签名文件.jks 。然后回车会提示你输入你的签名密码，输入后回车-&gt;你会看你签名打包后的apk的sha1 </code></pre><p>   方式二 ：</p>
<pre><code>cmd 打开dos-&gt; cd+keytool路径（keytool 在你jdk bin包下）+keytool -v -list -keystore +签名文件路径+签名文件.jks -&gt;然后回车会提示你输入你的签名密码，输入后回车-&gt;你也会看你签名打包后的apk的sha1 </code></pre><p>然后在相应的平台（比如我的是高德地图API平台）在发布SHA1那一栏输入上面获得的SHA1，调试SHA1那一栏就是之前那个SHA1<br>注意:这个SHA1和你创建key相关，即每一个新的key所生成的SHA1都不一样</p>
</li>
<li><h4 id="当某个文件拒绝访问时："><a href="#当某个文件拒绝访问时：" class="headerlink" title="当某个文件拒绝访问时："></a>当某个文件拒绝访问时：</h4><p>我们可以修改该文件的权限：右击该文件-&gt;属性-&gt;修改文件所有者或者权限</p>
<a id="more"></a>
</li>
<li><h4 id="kali开启图形界面卡在鼠标不动："><a href="#kali开启图形界面卡在鼠标不动：" class="headerlink" title="kali开启图形界面卡在鼠标不动："></a>kali开启图形界面卡在鼠标不动：</h4><p>在命令行界面，即level 3下使用startx命令或init 5命令或两者结合(所以提前要默认命令行界面运行)。</p>
</li>
<li><h4 id="github创建sshkey-在gitBash中使用命令："><a href="#github创建sshkey-在gitBash中使用命令：" class="headerlink" title="github创建sshkey,在gitBash中使用命令："></a>github创建sshkey,在gitBash中使用命令：</h4><p>ssh-keygen -t rsa -b 4096 -C “你的邮箱”,一路enter,找到创建时存放.rsa.pub的文件，打开，复制，放到github上去</p>
</li>
<li><h4 id="VS2017进行网络编程需要配置："><a href="#VS2017进行网络编程需要配置：" class="headerlink" title="VS2017进行网络编程需要配置："></a>VS2017进行网络编程需要配置：</h4><p>项目属性-&gt;链接库-&gt;输入里面加如ws2_32.lib，同时注意上面的debug是x86，而不是x64，同时应使用#include&lt;WS2tcpip.h&gt;头文件，因为#include &lt;Winsock2.h&gt;的方法在x64上会产生不可预知错误</p>
</li>
<li><h4 id="vs拓展工具下载太慢解决方法："><a href="#vs拓展工具下载太慢解决方法：" class="headerlink" title="vs拓展工具下载太慢解决方法："></a>vs拓展工具下载太慢解决方法：</h4><p>更改适配器-&gt;属性-&gt;去掉ipv6前的勾</p>
</li>
<li><h4 id="网络编程一些测试可能需要关闭防火墙，网络编程一些error4996错误解决："><a href="#网络编程一些测试可能需要关闭防火墙，网络编程一些error4996错误解决：" class="headerlink" title="网络编程一些测试可能需要关闭防火墙，网络编程一些error4996错误解决："></a>网络编程一些测试可能需要关闭防火墙，网络编程一些error4996错误解决：</h4><ol>
<li>在项目名称上右键，打开属性</li>
<li>在属性中找到预处理器定义</li>
<li>在预处理器定义中添加以下代码<br>_WINSOCK_DEPRECATED_NO_WARNINGS</li>
</ol>
</li>
<li><h4 id="Android-Studio-编译不通过，报错“找不到org-apache-http-HttpEntity”"><a href="#Android-Studio-编译不通过，报错“找不到org-apache-http-HttpEntity”" class="headerlink" title="Android Studio 编译不通过，报错“找不到org.apache.http.HttpEntity”"></a>Android Studio 编译不通过，报错“找不到org.apache.http.HttpEntity”</h4><p>如果你使用的target sdk是23以上请在module下的build.gradle加入android{ useLibrary ‘org.apache.http.legacy’ }</p>
</li>
<li><h4 id="没有快捷键的eclipse，代码敲起来太慢，还是使用快捷键补全更方便"><a href="#没有快捷键的eclipse，代码敲起来太慢，还是使用快捷键补全更方便" class="headerlink" title="没有快捷键的eclipse，代码敲起来太慢，还是使用快捷键补全更方便:"></a>没有快捷键的eclipse，代码敲起来太慢，还是使用快捷键补全更方便:</h4><ol>
<li>打开Eclipse，点击”Window － Preferences”;</li>
<li>在目录树上选择”Java——Editor——Content Assist”，在右侧的”Auto-Activation”找到”Auto Activation triggers for java”选项;</li>
<li>在”Auto Activation triggers for java”选项中，默认触发代码提示的就是”.”这个符号。将”.”后面加入所有的英文大小写字母，更改：.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</li>
<li>更改完成后就可以使用快捷键，迅速敲代码了。</li>
</ol>
</li>
<li><p>在javaEE中设置自动提示：</p>
<p>a. 设置html文件的自动代码提示：</p>
<ol>
<li>在Preferences中找到Web–&gt;HTML Files–&gt;Editor–&gt;Content Assist</li>
<li>然后将Prompt when these characters are inserted右边的输入框中的”&lt;=”改为你想输入后就会提示的内容</li>
<li>我是改为”&lt;=abcdefghijklmnopqrstuvwxyz”。上面的Auto activation delay(ms)是指代码提示延迟的时间(默认500ms)。</li>
</ol>
<p>b. 设置xml文件的自动代码提示：</p>
<ol>
<li>在Preferences中找到XML–&gt;XML Files–&gt;Editor–&gt;Content Assist</li>
<li>然后将Prompt when these characters are inserted右边的输入框中的”&lt;=:”改为你想输入后就会提示的内容</li>
<li>我是改为”&lt;=:abcdefghijklmnopqrstuvwxyz”</li>
</ol>
</li>
<li><h4 id="eclipse会联网下载“代码建议器”的东西，有时没网或有代理等情况，会失败，弹出这类提示："><a href="#eclipse会联网下载“代码建议器”的东西，有时没网或有代理等情况，会失败，弹出这类提示：" class="headerlink" title="eclipse会联网下载“代码建议器”的东西，有时没网或有代理等情况，会失败，弹出这类提示："></a>eclipse会联网下载“代码建议器”的东西，有时没网或有代理等情况，会失败，弹出这类提示：</h4><p>Window-&gt;Preferences-&gt;General-&gt;Network Connections-&gt;以上将Active Provider修改为手动方式，一般情况下不会弹出了，之后还会弹出的话，在弹出对话框选择忽略掉就OK。</p>
</li>
<li><h4 id="“https-api-weixin-qq-com-cgi-bin-menu-create-access-token-quot-wxService-needGetAccessToken-微信接口出现40001错误，即accesstoken无效或超时："><a href="#“https-api-weixin-qq-com-cgi-bin-menu-create-access-token-quot-wxService-needGetAccessToken-微信接口出现40001错误，即accesstoken无效或超时：" class="headerlink" title="“https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;+ wxService.needGetAccessToken();微信接口出现40001错误，即accesstoken无效或超时："></a>“<a href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;+" target="_blank" rel="external nofollow noopener noreferrer">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;+</a> wxService.needGetAccessToken();微信接口出现40001错误，即accesstoken无效或超时：</h4><p>可能是源码页面编码格式不正确(utf-8)尽量别用replace方法，不要直接在类中用字面量，可以用配置文件</p>
</li>
<li><h4 id="Android-Studio一片爆红，代码中各种jdk和sdk的类找不到，提示setup-jdk："><a href="#Android-Studio一片爆红，代码中各种jdk和sdk的类找不到，提示setup-jdk：" class="headerlink" title="Android Studio一片爆红，代码中各种jdk和sdk的类找不到，提示setup jdk："></a>Android Studio一片爆红，代码中各种jdk和sdk的类找不到，提示setup jdk：</h4><p>解决方法：点击 File-&gt;Invalidate Caches/Restart ，然后点击Invalidate and Restart</p>
</li>
<li><h4 id="eclipse创建maven项目注意："><a href="#eclipse创建maven项目注意：" class="headerlink" title="eclipse创建maven项目注意："></a>eclipse创建maven项目注意：</h4><p>elcipse没有src/main/java和src/test/java两个路径:先右击项目&gt;Buildpath&gt;Config…&gt;Source去掉两个missing的路径，然后apply返回&gt;右击项目&gt;新建Source floder&gt;创建两个路径</p>
</li>
<li><h4 id="bootstrap4做前端时一个莫名奇妙的问题："><a href="#bootstrap4做前端时一个莫名奇妙的问题：" class="headerlink" title="bootstrap4做前端时一个莫名奇妙的问题："></a>bootstrap4做前端时一个莫名奇妙的问题：</h4><p>当f12打开调试台后，给下拉框添加的Class看不到效果，关了f12即可</p>
</li>
<li><h4 id="maven中配置spring报如下错误-Multiple-annotations-found-at-this-line-lt-…-gt-："><a href="#maven中配置spring报如下错误-Multiple-annotations-found-at-this-line-lt-…-gt-：" class="headerlink" title="maven中配置spring报如下错误:Multiple annotations found at this line&lt;…&gt;："></a>maven中配置spring报如下错误:Multiple annotations found at this line&lt;…&gt;：</h4><ul>
<li>原因:文件中的配置和我pom.xml下载的spring版本不一致导致</li>
<li>解决:给我的spring配置文件中的带.xsd后缀的那一部分的版本改为我pom.xml中的版本，如果还不行，就再执行一次clean操作</li>
</ul>
</li>
<li><h4 id="解决spring配置文件和国际化资源文件不在同一个目录下路径访问不到问题：不知道可不可以用相对路径-有待测试"><a href="#解决spring配置文件和国际化资源文件不在同一个目录下路径访问不到问题：不知道可不可以用相对路径-有待测试" class="headerlink" title="解决spring配置文件和国际化资源文件不在同一个目录下路径访问不到问题：不知道可不可以用相对路径(有待测试)"></a>解决spring配置文件和国际化资源文件不在同一个目录下路径访问不到问题：不知道可不可以用相对路径(有待测试)</h4><p>文件路径未被spring读取，message_zh_CN.properties存放在src/conf包下。最后将配置message文件目录修改如下，最终问题解决</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"conf/message"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useCodeAsDefaultMessage"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在加载其他资源文件&lt;context:property-placeholder location=”classpath:conf/resource.properties” ignore-unresolvable=”true” /&gt;，加入classpath是可以的，但是放到messageSource却不可以</p>
</li>
<li><h4 id="eclipse-javaEE常用快捷键："><a href="#eclipse-javaEE常用快捷键：" class="headerlink" title="eclipse javaEE常用快捷键："></a>eclipse javaEE常用快捷键：</h4><ol>
<li>alt+↑当前行和上一行交换；alt+↓当前行和下一行交换</li>
<li>ctrl+d删除当前行，ctrl+shift+o快速导包</li>
<li>shift+enter光标移到下一行，ctrl+shift+enter移到下一行光标不动</li>
<li>ctrl+shift+f格式化代码，Ctrl+Shift+S保存全部</li>
<li>Ctrl+Alt+↓ 复制当前行到下一行(复制增加)，Ctrl+Alt+↑ 复制当前行到上一行(复制增加)</li>
<li>一整块后移是：tab，一整块前移是：shift+tab</li>
</ol>
</li>
<li><h4 id="androidStudio常用快捷键"><a href="#androidStudio常用快捷键" class="headerlink" title="androidStudio常用快捷键:"></a>androidStudio常用快捷键:</h4><ol>
<li>Ctrl + Shift +↑ 或 ↓：把当前作用域的代码提前或者后退一行，Ctrl + D：复制当前行到下一行</li>
<li>Ctrl + P：把光标移动到方法后面的括号内，点击后可以提示你方法的参数类型</li>
<li>Ctrl+J：同时按下Ctrl和J快捷键，弹出快捷代码框,对于一些常用的代码Android Studio中进行了封装，直接选中即可快速生成，在开发中十分实用，这里以打印log和弹出Toast为例。首先按下Ctrl+J快捷键，弹出快捷代码框，然后直接输入logd这一快捷代码的“命令”，打印Log需要TAG，在类的最上方输入快捷代码logt，即可快速生成一个TAG同样，先输入Ctrl+J键，弹出快捷代码框，然后直接输入toast按下Enter键，或者有了Toast以后按下Ta,快速生成了一行Toast语句，在引号中输入要Toast显示的信息即可</li>
<li>Ctrl+F12：在类中方法比较多的情况下，同时按下Ctrl和F12键可以快速查看类中所有的方法，弹出这个框的同时可以直接输入想要搜索的方法，进行快速匹配。</li>
<li><strong>Ctrl+Alt+L：对当前类的所有代码进行格式化</strong></li>
<li>Ctrl+Alt+V：此快捷键可以快速声明一个变量，本地变量赋值</li>
<li>Ctrl+Alt+H：点中某一个方法按下这个快捷键，在左边栏上弹出此方法的调用关系，此快捷键在开发中十分常用。</li>
<li><strong>Ctrl+Alt+O：这个快捷键可以自动导包或删除无用的包，这时候按下快捷键即可自动删除这些无用的包</strong></li>
<li>Alt+Insert：同时按下Alt和Insert键，弹出快速代码生成框，有构造方法、getter/setter方法、toString方法等Android Studio快速代码生成框。</li>
</ol>
</li>
<li><h4 id="win10修复系统组件"><a href="#win10修复系统组件" class="headerlink" title="win10修复系统组件"></a>win10修复系统组件</h4><p>搜索命令提示符，右击以<strong>管理员身份</strong>运行命令提示符，输入以下命令，注意空格(可以直接复制)</p>
<ol>
<li>扫描映像：DISM.exe /Online /Cleanup-image /Scanhealth</li>
<li><strong>如果第一条命令提示存在错误，则输入以下命令，检测映像。如果无错误就输入第四条命令</strong>：DISM.exe /Online /Cleanup-image /Checkhealth</li>
<li>修复映像：DISM.exe /Online /Cleanup-image /Restorehealth</li>
<li>最后检查系统并修复：sfc /scannow</li>
<li><strong>注意以上命令需要在正常联网的情况下使用</strong></li>
</ol>
</li>
<li><h4 id="win10安全中心一片空白解决办法：将下面代码复制为-reg文件执行然后重启即可。"><a href="#win10安全中心一片空白解决办法：将下面代码复制为-reg文件执行然后重启即可。" class="headerlink" title="win10安全中心一片空白解决办法：将下面代码复制为.reg文件执行然后重启即可。"></a>win10安全中心一片空白解决办法：将下面代码复制为.reg文件执行然后重启即可。</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender]</span><br><span class="line">"DisableAntiSpyware"=dword:<span class="number">00000000</span></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-<span class="built_in">Time</span> Protection]</span><br><span class="line">"DisableBehaviorMonitoring"=dword:<span class="number">00000000</span></span><br><span class="line">"DisableIOAVProtection"=dword:<span class="number">00000000</span></span><br><span class="line">"DisableOnAccessProtection"=dword:<span class="number">00000000</span></span><br><span class="line">"DisableRealtimeMonitoring"=dword:<span class="number">00000000</span></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecurityHealthService]</span><br><span class="line">"<span class="built_in">Start</span>"=dword:<span class="number">00000002</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="初始化顺序-（优先级从高到低）"><a href="#初始化顺序-（优先级从高到低）" class="headerlink" title="初始化顺序:（优先级从高到低）"></a>初始化顺序:（优先级从高到低）</h4><p>静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法。<br>其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。</p>
</li>
<li><h4 id="Android上使用Smack踩坑："><a href="#Android上使用Smack踩坑：" class="headerlink" title="Android上使用Smack踩坑："></a>Android上使用Smack踩坑：</h4><ol>
<li><p>不要将所有的包导入，将一些需要的包导入即可，因为一些包在Android上会起冲突</p>
</li>
<li><p>注意一些api的更新，比如setHost不能用于设置ip，需要使用setHostAddressByNameOrIp方法，否则会报空指针异常</p>
</li>
<li><p>使用smack之前需要初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        AndroidSmackInitializer androidSmackInitializer = <span class="keyword">new</span> AndroidSmackInitializer();</span><br><span class="line">        androidSmackInitializer.initialize();</span><br><span class="line">        <span class="comment">//需要手动加载下面这个类，否则会报找不到该类的错误</span></span><br><span class="line">        <span class="comment">//Caused by: java.lang.ClassNotFoundException:</span></span><br><span class="line">        <span class="comment">//Didn't find class "org.minidns.hla.DnssecResolverApi" on path</span></span><br><span class="line">       SmackConfiguration.addDisabledSmackClass(<span class="string">"org.jivesoftware.smack.util.dns.minidns.MiniDnsResolver"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要导入一些额外的包，比如org.jxmpp…</p>
</li>
</ol>
</li>
<li><h4 id="android在gradle出现can’t-connect错误："><a href="#android在gradle出现can’t-connect错误：" class="headerlink" title="android在gradle出现can’t connect错误："></a>android在gradle出现can’t connect错误：</h4><p>主要是无法链接下载网站，因为一般都是从Google、国外镜像获取的资源，所以有时很慢甚至连接不上<br>解决方法：找到build.gradle(Project:你的项目名)-&gt;在该文件中找到如下的部分对应修改(<strong>！！！两个，两个都要改！！！！</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">		<span class="comment">//注释掉原来的镜像</span></span><br><span class="line">		<span class="comment">//google()</span></span><br><span class="line">		<span class="comment">//jcenter()</span></span><br><span class="line">		<span class="comment">//改成阿里云的镜像</span></span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/gradle-plugin'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="java存在继承的情况下，初始化顺序为-从上到下-："><a href="#java存在继承的情况下，初始化顺序为-从上到下-：" class="headerlink" title="java存在继承的情况下，初始化顺序为(从上到下)："></a>java存在继承的情况下，初始化顺序为(从上到下)：</h4><p>​    父类（静态变量、静态语句块）<br>​    子类（静态变量、静态语句块）<br>​    父类（实例变量、普通语句块）<br>​    父类（构造函数）<br>​    子类（实例变量、普通语句块）<br>​    子类（构造函数）</p>
</li>
<li><h4 id="maven项目下的classpath："><a href="#maven项目下的classpath：" class="headerlink" title="maven项目下的classpath："></a>maven项目下的classpath：</h4><p><strong>假设资源文件放在maven工程的 src/main/resources 资源文件夹下,源码文件放在 src/main/java/下,</strong><br><strong>那么java文件夹和resources文件夹在运行时就是classpath的真实位置</strong>，如果：<br>有一个文件位于 src/main/resources/test.txt，有一个类位于 src/main/java/com/qunar/MyClass.java<br>FILE_NAME = “test.txt”<br>通过如下代码：MyClass.class.getClassLoder().getResource(FILE_NAME).getPath();直接获取文件路径而classpath可以通过如下代码获取：MyClass.class.getClassLoder().getResource(“”).getPath();<br>还有一种方法可以通过当前类的加载路径使用相对路径来获取资源地址：<br>MyClass.class.getResource(FILE_NAME).getPath();<br>那么这种就会有问题,因为此时的路径是相对于MyClass这个类在运行时路径而言的,test.txt和MyClass并不在一个层级,因为MyClass之前还有两个包<br>可以如下解决：<br>MyClass.class.getResource(File.separator + “FILE_NAME”).getPath(); // 这种方法相当于使用绝对运行时路径<br>MyClass.class.getResource(“..” + File.separator + “..” + File.separator + FILE_NAME).getPath(); // 这种方法相当于使用相对MyClass的运行时路径</p>
</li>
<li><h4 id="maven构建spring配置文件时出现无法读取文案文档错误："><a href="#maven构建spring配置文件时出现无法读取文案文档错误：" class="headerlink" title="maven构建spring配置文件时出现无法读取文案文档错误："></a>maven构建spring配置文件时出现无法读取文案文档错误：</h4><p>通过查看日志文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Loaded schema mappings: &#123;</span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/tx/spring-tx-2.5.xsd=org/springframework/transaction/config/spring-tx-2.5.xsd, </span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop-4.1.xsd, </span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd, </span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/util/spring-util-3.0.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd,</span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/mvc/spring-mvc-4.1.xsd=org/springframework/web/servlet/config/spring-mvc-4.1.xsd,</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>发现这些xsd配置都没有如4.1.7这样版本的。</strong></p>
<p>解决方法：如果pom.xml是如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么spring配置文件中应该如此配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/tx </span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/tx/spring-tx-4.1.xsd</span></span><br></pre></td></tr></table></figure>

<p>而不应该如此配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/tx </span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/tx/spring-tx-4.1.7.xsd</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="spring-mvc开发过程中-经常会给model-addAttribute-然后通过EL在jsp中显示-比如-msg-但是有时候会出现jsp最后显示的还是-msg-而不是msg赋值过的："><a href="#spring-mvc开发过程中-经常会给model-addAttribute-然后通过EL在jsp中显示-比如-msg-但是有时候会出现jsp最后显示的还是-msg-而不是msg赋值过的：" class="headerlink" title="spring mvc开发过程中, 经常会给model addAttribute, 然后通过EL在jsp中显示,比如 ${msg},但是有时候会出现jsp最后显示的还是${msg},而不是msg赋值过的："></a>spring mvc开发过程中, 经常会给model addAttribute, 然后通过EL在jsp中显示,比如 ${msg},但是有时候会出现jsp最后显示的还是${msg},而不是msg赋值过的：</h4><ol>
<li><p>原因在于老的JSP 1.2 声明，web.xml中是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">//...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>EL是默认关闭的。。。必须<strong>手动打开</strong>，即添加&lt;%@ page isELIgnored=”false” %&gt;</p>
</li>
<li><p>将web.xml头部信息改为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="spring配置文件头需要在最后一个后面加一个空格，否则最后一个不会生效，如："><a href="#spring配置文件头需要在最后一个后面加一个空格，否则最后一个不会生效，如：" class="headerlink" title="spring配置文件头需要在最后一个后面加一个空格，否则最后一个不会生效，如："></a>spring配置文件头需要在最后一个后面加一个空格，否则最后一个不会生效，如：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation=<span class="string">" http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">				   http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span><br><span class="line"><span class="string">				   http://www.springframework.org/schema/context </span></span><br><span class="line"><span class="string">				   http://www.springframework.org/schema/context/spring-context-4.1.xsd "</span>&gt;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.springframework.org/schema/context/spring-context-4.1.xsd后面加了个**空格**！！！" target="_blank" rel="external nofollow noopener noreferrer">http://www.springframework.org/schema/context/spring-context-4.1.xsd后面加了个**空格**！！！</a></p>
</li>
<li><h4 id="IDEA控制台莫名其妙乱码问题，然后莫名其妙的解决："><a href="#IDEA控制台莫名其妙乱码问题，然后莫名其妙的解决：" class="headerlink" title="IDEA控制台莫名其妙乱码问题，然后莫名其妙的解决："></a>IDEA控制台莫名其妙乱码问题，然后莫名其妙的解决：</h4><p>因为工程中添加了其他编码文件，当我把其他编码文件都去掉(或者都改为utf-8)后，乱码问题解决。。。。。</p>
</li>
<li><h4 id="ASCII须记住-’0’对应十进制48-’A’对应十进制65-’a’对应十进制97"><a href="#ASCII须记住-’0’对应十进制48-’A’对应十进制65-’a’对应十进制97" class="headerlink" title="ASCII须记住:’0’对应十进制48,’A’对应十进制65,’a’对应十进制97"></a>ASCII须记住:’0’对应十进制48,’A’对应十进制65,’a’对应十进制97</h4></li>
<li><h4 id="jdk自带有个jvisualvm工具、该工具是用来监控java运行程序的cpu、内存、线程等的使用情况，在cmd中输入jvisualvm即可看到。"><a href="#jdk自带有个jvisualvm工具、该工具是用来监控java运行程序的cpu、内存、线程等的使用情况，在cmd中输入jvisualvm即可看到。" class="headerlink" title="jdk自带有个jvisualvm工具、该工具是用来监控java运行程序的cpu、内存、线程等的使用情况，在cmd中输入jvisualvm即可看到。"></a>jdk自带有个jvisualvm工具、该工具是用来监控java运行程序的cpu、内存、线程等的使用情况，在cmd中输入jvisualvm即可看到。</h4></li>
<li><h4 id="ResourBundle读取资源包下的配置文件时要注意路径，注意下面这个最简单的读取配置文件实例："><a href="#ResourBundle读取资源包下的配置文件时要注意路径，注意下面这个最简单的读取配置文件实例：" class="headerlink" title="ResourBundle读取资源包下的配置文件时要注意路径，注意下面这个最简单的读取配置文件实例："></a>ResourBundle读取资源包下的配置文件时要注意路径，注意下面这个最简单的读取配置文件实例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedProFile</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">	String resourceFile = <span class="string">"Forum.CNS"</span>;    </span><br><span class="line"><span class="comment">//	        创建一个默认的ResourceBundle对象   </span></span><br><span class="line"><span class="comment">//	        ResourceBundle会查找包Forum下的CNS.properties的文件   </span></span><br><span class="line"><span class="comment">//	        Forum是资源的包名，它跟普通java类的命名规则完全一样：   </span></span><br><span class="line"><span class="comment">//	        - 区分大小写   </span></span><br><span class="line"><span class="comment">//	        - 扩展名 .properties 省略。就像对于类可以省略掉 .class扩展名一样   </span></span><br><span class="line"><span class="comment">//	        - 资源文件必须位于指定包的路径之下（位于所指定的classpath中）   </span></span><br><span class="line"><span class="comment">//            假如你是在非Web项目中使用，则一定要写资源文件的路径，也就是包路径必须存在。</span></span><br><span class="line"><span class="comment">//            如果是Web项目，不写包路径可以，此时将资源文件放在WEB-INF\classes\目录下就可以。</span></span><br><span class="line">	ResourceBundle rb = ResourceBundle.getBundle(resourceFile);</span><br><span class="line">	System.out.println(rb.getString(<span class="string">"DRIVER"</span>));<span class="comment">//这里是分大小写的，嘿嘿输出值为jdbc:mysql://localhost:3306/cns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="redis错误：Caused-by-redis-clients-jedis-exceptions-JedisDataException"><a href="#redis错误：Caused-by-redis-clients-jedis-exceptions-JedisDataException" class="headerlink" title="redis错误：Caused by: redis.clients.jedis.exceptions.JedisDataException:"></a>redis错误：Caused by: redis.clients.jedis.exceptions.JedisDataException:</h4><p>官方解释：DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified,  no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface.</p>
<p>If you want to connect from external computers to Redis you may adopt one of the following solutions:</p>
<ol>
<li>Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running,however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent.</li>
<li>Alternatively you can just disable the protected mode by editing the Redis configuration file,and setting the protected mode option to ‘no’, and then restarting the server. </li>
<li>If you started the server manually just for testing, restart it with the ‘–protected-mode no’ option.</li>
<li><strong>Setup a bind address or an authentication password.</strong> </li>
<li>NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.</li>
<li>一般就是没有设置密码，可以设置密码后认证登录，也就是方案4</li>
</ol>
</li>
<li><h4 id="ubuntu18-04配置静态ip"><a href="#ubuntu18-04配置静态ip" class="headerlink" title="ubuntu18.04配置静态ip"></a>ubuntu18.04配置静态ip</h4><ol>
<li><p>配置静态ip相关链接：</p>
<p><a href="https://www.cnblogs.com/SH170706/p/10357676.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/SH170706/p/10357676.html</a></p>
<p><a href="https://blog.csdn.net/makenothing/article/details/9527149" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/makenothing/article/details/9527149</a></p>
<p><a href="https://www.cnblogs.com/ermao0423/p/9954314.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/ermao0423/p/9954314.html</a></p>
</li>
<li><p>ubuntu修改用户名和主机名<br><a href="https://www.cnblogs.com/zeusmyth/p/6231350.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/zeusmyth/p/6231350.html</a></p>
</li>
<li><p>oracle官网(和标题无关)<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/" target="_blank" rel="external nofollow noopener noreferrer">http://www.oracle.com/technetwork/java/javase/downloads/</a></p>
</li>
</ol>
</li>
<li><h4 id="idea从GitHub或码云中导入maven项目时pom-xml爆红"><a href="#idea从GitHub或码云中导入maven项目时pom-xml爆红" class="headerlink" title="idea从GitHub或码云中导入maven项目时pom.xml爆红"></a>idea从GitHub或码云中导入maven项目时pom.xml爆红</h4><p>首先将该项目弄为maven项目(因为可能一开始还不是)-&gt;找到右边的maven标签下的Lifecycle-&gt;clean-&gt;install-&gt;reimportant-&gt;重启</p>
</li>
<li><h4 id="hexo的一点优化"><a href="#hexo的一点优化" class="headerlink" title="hexo的一点优化"></a>hexo的一点优化</h4><ol>
<li><a href="https://source.unsplash.com/random/1600x900?wallpapers免费背景图地址" target="_blank" rel="external nofollow noopener noreferrer">https://source.unsplash.com/random/1600x900?wallpapers免费背景图地址</a></li>
<li>next主题中一些东西失效解决办法：f12查看-&gt;找到失效链接-&gt;更新该链接</li>
<li>next主题中不想首页显示全文方法：在写.md文件时在你想截断的地方加上&lt;!– more –&gt;</li>
</ol>
</li>
<li><h4 id="hexo修改next-5-1-4主题宽度"><a href="#hexo修改next-5-1-4主题宽度" class="headerlink" title="hexo修改next 5.1.4主题宽度"></a>hexo修改next 5.1.4主题宽度</h4><ol>
<li><p>进入目录：\hexo\themes\next\source\css_variables</p>
</li>
<li><p>打开base.styl文件，修改如下(这是我修改后的)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$main-desktop                   = 1060px</span><br><span class="line">$main-desktop-large             = 1500px</span><br><span class="line"></span><br><span class="line">$content-desktop                = 800px</span><br><span class="line">$content-desktop-large          = 1200px</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意保持main-desktop和content-desktop以及main-desktop-large和content-desktop-large的比例和之前一样，否则布局会乱</strong></p>
</li>
</ol>
</li>
<li><h4 id="sql语句中：where-gt-group-by-gt-having-gt-order-by"><a href="#sql语句中：where-gt-group-by-gt-having-gt-order-by" class="headerlink" title="sql语句中：where&gt;group by&gt;having&gt;order by"></a>sql语句中：where&gt;group by&gt;having&gt;order by</h4></li>
<li><h4 id="事务的传播性"><a href="#事务的传播性" class="headerlink" title="事务的传播性"></a>事务的传播性</h4><ol>
<li>PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启</li>
<li>PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li>
<li>PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起</li>
<li>PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务</li>
<li>PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常</li>
<li>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</li>
</ol>
</li>
<li><h4 id="mysql事务隔离：mysql默认是可重复读"><a href="#mysql事务隔离：mysql默认是可重复读" class="headerlink" title="mysql事务隔离：mysql默认是可重复读"></a>mysql事务隔离：mysql默认是可重复读</h4><ol>
<li>ISOLATION_DEFAULT：这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别，另外四个与JDBC的隔离级别相对应</li>
<li>ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据，这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li>ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据，也叫不可重复读</li>
<li>ISOLATION_REPEATABLE_READ：可重复读，这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读，它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</li>
<li>ISOLATION_SERIALIZABLE：可串行化，这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行，除了防止脏读，不可重复读外，还避免了幻像读。</li>
</ol>
</li>
<li><h4 id="IDEA自带maven插件的问题"><a href="#IDEA自带maven插件的问题" class="headerlink" title="IDEA自带maven插件的问题"></a>IDEA自带maven插件的问题</h4><ol>
<li>我们可能习惯使用自己下载的maven，那么在创建maven工程的时候需要修改maven的目录以及配置文件地址</li>
<li>同时我们还需要将idea自带的maven的配置文件和我们自己的maven配置文件同步。idea自带maven插件地址：你的idea安装目录\plugins\maven\lib，你会发现下面有maven2和maven3两个文件夹，打开，将里面的配置文件都修改为你自己的maven配置文件所配置的格式，否则idea的maven有些地方还是会使用到自带的maven配置文件</li>
<li>idea中maven索引无法更新的问题解决：<a href="http://www.zhaojun.im/maven-mirror-index/" target="_blank" rel="external nofollow noopener noreferrer">http://www.zhaojun.im/maven-mirror-index/</a></li>
</ol>
</li>
<li><h4 id="spring中classpath和classpath-的区别"><a href="#spring中classpath和classpath-的区别" class="headerlink" title="spring中classpath和classpath*的区别"></a>spring中classpath和classpath*的区别</h4><ol>
<li>classpath：只会到你的class路径中查找找文件;</li>
<li>classpath*：不仅包含class路径，还会到引入的jar中(class路径)进行查找.</li>
</ol>
</li>
<li><h4 id="hexo中分页显示问题（出现-lt-i-class-“fa-fa-angle-right”-gt-lt-i-gt"><a href="#hexo中分页显示问题（出现-lt-i-class-“fa-fa-angle-right”-gt-lt-i-gt" class="headerlink" title="hexo中分页显示问题（出现&lt;i class = “fa fa-angle-right”&gt;&lt;/i&gt;)"></a>hexo中分页显示问题（出现&lt;i class = “fa fa-angle-right”&gt;&lt;/i&gt;)</h4><p>修改：/themes/next/layout/_partials/pagination.swig</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"pagination"</span>&gt;</span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: <span class="string">'&lt;i class="fa fa-angle-left" aria-label="'</span>+__(<span class="string">'accessibility.prev_page'</span>)+<span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">       next_text: <span class="string">'&lt;i class="fa fa-angle-right" aria-label="'</span>+__(<span class="string">'accessibility.next_page'</span>)+<span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">       mid_size: <span class="number">1</span>,</span><br><span class="line">       <span class="built_in">escape</span>: <span class="literal">false</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">&#123;%- endif %&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Crack-IDEA-注意：亲测版本2019-3-2可用，2020以后版本无法搞定！！！-问题-使用的是zhile大神的crack包-：突然弹出授权框，原因未知"><a href="#Crack-IDEA-注意：亲测版本2019-3-2可用，2020以后版本无法搞定！！！-问题-使用的是zhile大神的crack包-：突然弹出授权框，原因未知" class="headerlink" title="Crack IDEA(注意：亲测版本2019.3.2可用，2020以后版本无法搞定！！！)问题(使用的是zhile大神的crack包)：突然弹出授权框，原因未知"></a>Crack IDEA<strong>(注意：亲测版本2019.3.2可用，2020以后版本无法搞定！！！</strong>)问题(使用的是zhile大神的crack包)：突然弹出授权框，原因未知</h4><ol>
<li><p>先通过免费30天进入idea(如果提示30天已过，解压zhile大神提供的 jetbrains-agent-latest.zip –&gt; reset_eval –&gt;根据自己的版本选择不同的文件点击–&gt;重置成功，然后在执行第一步)。</p>
</li>
<li><p>进入之后，不要使用拖拽的形式将jetbrains-agent-latest.zip导入，而是点击helpe –&gt; Edit Custom VM Options –&gt;将</p>
<p>-javaagent:C:\Users\Public.jetbrains\jetbrains-agent-v3.1.3.0cd4.033注释掉(如果有-javaagent的话，将那一行注释掉)，然后在输入-javaagent:你的idea目录\bin\jetbrains-agent.jar，后面这个jetbrains-agent.jar文件是需要自己添加的，也是在zhile大神提供的zip包中</p>
</li>
<li><p>然后重启，就会弹出熟悉的crack窗口，根据需要选择自己crack的方式，进入之后查看about就会发现crack success，授权至2089年</p>
</li>
</ol>
</li>
<li><h4 id="VScode在windows上安装的一点注意事项"><a href="#VScode在windows上安装的一点注意事项" class="headerlink" title="VScode在windows上安装的一点注意事项"></a>VScode在windows上安装的一点注意事项</h4><ol>
<li>安装时选择.zip安装</li>
<li>解压之后在和Code.exe同级的目录下创建data文件夹</li>
<li>如果没有按照上两步来，vscode可能就会在一些你无法预知的目录输出数据，比如在系统盘下的Appdata或program files目录下</li>
</ol>
</li>
<li><h4 id="java对读取文件的支持："><a href="#java对读取文件的支持：" class="headerlink" title="java对读取文件的支持："></a>java对读取文件的支持：</h4><ol>
<li><a href="https://www.cnblogs.com/huaxingtianxia/p/5609237.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/huaxingtianxia/p/5609237.html</a></li>
<li>个人见解：如果是类似XXX.class.getResourceAsStream或者XXX.class.getResource直接调用的这些方法，传入的文件路径参数一定是以”/“开头，而如果是XXX.class.getClassLoader().getResourceAsStream或者XXX.class.getClassLoader().getResource这类通过ClassLoader调用的读取文件方法，那么传入的文件路径参数不能是以”/“开头。二者都是相对工程根目录来说的，所以都不要添加src，比如src下有一个netcode包，该包下有一个a.txt文件，那么路径可以是”/netcode/a.txt”或者”netcode/a.txt”，两个路径分别对应上面两种情况</li>
<li>注意：上面这些只适用于获取只需读取的文件路径，不适用于获取写入的文件路径。如果需要写入的文件路径使用上面这些方法来获得，那么最终写入的文件位置是位于classpath路径下的那个同名文件中，而不是你自己指定的那个文件地址。</li>
</ol>
</li>
<li><h4 id="IDEA中shift-0-ins-键切换光标形式"><a href="#IDEA中shift-0-ins-键切换光标形式" class="headerlink" title="IDEA中shift + 0(ins)键切换光标形式"></a>IDEA中shift + 0(ins)键切换光标形式</h4></li>
<li><h4 id="当使用cmd编译运行java程序时，如果编译后的-class文件是在某个特定目录下，不能简单跳转到该目录下直接使用java来运行，否则会提示找不到主类。如下所示"><a href="#当使用cmd编译运行java程序时，如果编译后的-class文件是在某个特定目录下，不能简单跳转到该目录下直接使用java来运行，否则会提示找不到主类。如下所示" class="headerlink" title="当使用cmd编译运行java程序时，如果编译后的.class文件是在某个特定目录下，不能简单跳转到该目录下直接使用java来运行，否则会提示找不到主类。如下所示"></a>当使用cmd编译运行java程序时，如果编译后的.class文件是在某个特定目录下，不能简单跳转到该目录下直接使用java来运行，否则会提示找不到主类。如下所示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest&gt;cd out\production\ForOffer\netcode</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer\netcode&gt;java ChargenClient rama.poly.edu</span><br><span class="line"></span><br><span class="line">错误: 找不到或无法加载主类 ChargenClient</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer\netcode&gt;java .\ChargenClient rama.poly.edu</span><br><span class="line"></span><br><span class="line">错误: 找不到或无法加载主类 .\ChargenClient</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer\netcode&gt;cd ..</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer&gt;java .\netcode\ChargenClient rama.poly.edu</span><br><span class="line"></span><br><span class="line">错误: 找不到或无法加载主类 .\netcode\ChargenClient</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里路径的写法</span></span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer&gt;java netcode.ChargenClient rama.poly.edu</span><br><span class="line"></span><br><span class="line">java.net.ConnectException: Connection timed out: connect</span><br><span class="line"></span><br><span class="line">​    at sun.nio.ch.Net.connect0(Native Method)</span><br><span class="line"></span><br><span class="line">​    at sun.nio.ch.Net.connect(Net.java:<span class="number">454</span>)</span><br><span class="line"></span><br><span class="line">​    at sun.nio.ch.Net.connect(Net.java:<span class="number">446</span>)</span><br><span class="line"></span><br><span class="line">​    at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:<span class="number">648</span>)</span><br><span class="line"></span><br><span class="line">​    at java.nio.channels.SocketChannel.open(SocketChannel.java:<span class="number">189</span>)</span><br><span class="line"></span><br><span class="line">​    at netcode.ChargenClient.main(ChargenClient.java:<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">E:\software\IDEA2019\IDEA2019<span class="number">.3</span><span class="number">.2</span>Projects\ideaTest\out\production\ForOffer&gt;</span><br></pre></td></tr></table></figure>

<p>注意注释部分，也就是说在使用java命令运行时，需要加上外面一层的目录并且用”.”来代替”&quot;作为分隔符。</p>
</li>
<li><h4 id="ctrl-alt-space可以在pom中显示提示信息"><a href="#ctrl-alt-space可以在pom中显示提示信息" class="headerlink" title="ctrl + alt + space可以在pom中显示提示信息"></a>ctrl + alt + space可以在pom中显示提示信息</h4></li>
<li><h4 id="SpringAop基本组成"><a href="#SpringAop基本组成" class="headerlink" title="SpringAop基本组成"></a>SpringAop基本组成</h4><ol>
<li>@AspectJ:声明一个切面，一个切面由切点(@Pointcut)和通知(@Before、@After…)组成</li>
<li>@Pointcut切点：由一系列连接点(JoinPoint)组成，spring中最小连接点单位是方法，所以切点声明的表达式(@Point(“execution(* com.zachary.dao..<em>.</em>(..))”)）中一系列方法构成了切点，比如上面这个表达式可以这样看<em>(修饰符，*表示任何修饰符) com.zachary.dao(指定包)..</em>.*(..)表示该指定包下的子包下的任意类中的任意方法，并且方法参数任意</li>
<li>@Before、@After…通知：由切入时机(由注解指明)和切入内容(方法体中内容)构成，同时注解中参数可以指定切点(也就是承载切点的那个方法名)</li>
</ol>
</li>
<li><h4 id="comparable和comparator"><a href="#comparable和comparator" class="headerlink" title="comparable和comparator"></a>comparable和comparator</h4><ol>
<li><p>comparable：自然排序，需要集合中的对象本身实现comparable接口，并重写compareTo方法</p>
</li>
<li><p>comparator：可以在外部定制排序规则，需要创建实现了comparator接口的类并重写compare方法，然后作为参数传给排序类的某个方法</p>
</li>
<li><p>他们的返回值含义：-1，0，1三种，也可以理解为&lt;0，=0，&gt;0三种。</p>
<ul>
<li>当返回值小于0时，比较的两个对象不交换位置</li>
<li>当返回值等于0时，比较的两个对象不交换位置</li>
<li>当返回值大于0时，比较的两个对象交换位置</li>
</ul>
</li>
<li><p>即对comparator来说，在compare(Integer o1, Integer o2)方法中可以用：</p>
<p>return o1 - o2;来表示升序，return o2 - o1;来表示降序</p>
</li>
</ol>
</li>
<li><h4 id="AOP各个通知的执行顺序-注意注释部分位置"><a href="#AOP各个通知的执行顺序-注意注释部分位置" class="headerlink" title="AOP各个通知的执行顺序(注意注释部分位置)"></a>AOP各个通知的执行顺序(<strong>注意注释部分位置</strong>)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	Object result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//@Before</span></span><br><span class="line">		result = method.invoke(target, args);</span><br><span class="line">		<span class="comment">//@After</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">		Throwable targetException = e.getTargetException();</span><br><span class="line">		<span class="comment">//@AfterThrowing</span></span><br><span class="line">		<span class="keyword">throw</span> targetException;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//@AfterReturning</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="62">
<li><h4 id="markdown文件通过hexo转为html文件后，锚点问题"><a href="#markdown文件通过hexo转为html文件后，锚点问题" class="headerlink" title="markdown文件通过hexo转为html文件后，锚点问题"></a>markdown文件通过hexo转为html文件后，锚点问题</h4><p>在Markdown标题里面如果含有特殊字符比如()、\、/等字符，转为HTML文件后，这些字符都被短线<code>&#39;-&#39;</code>替代。比如Markdown标题为：SHUTDOWN()/SHUTDOWNNOW()方法介绍，转为HTML后这个id被设为：SHUTDOWN-SHUTDOWNNOW-方法介绍，所以放到个人博客上的Markdown文件锚点时需要使用HTML的id，而不是Markdown标题形式。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式基础</title>
    <url>/2020/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li><h2 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h2><p>在软件工程中，<strong>设计模式</strong>是对软件中<strong>普遍存在（反复出现）</strong>的各种问题，所提出的<strong>解决方案</strong>。</p>
</li>
<li><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>我们在编写程序的过程中，会面临着来自<strong>耦合性、内聚性、以及可维护性、可拓展性、可重用性、灵活性</strong>等多方面的挑战，设计模式就是为了让程序拥有更好的：</p>
<ol>
<li><p>代码重用性(即：相同功能的代码，不用多次编写)</p>
</li>
<li><p>可读性(即：编程规范性，便于其他程序员阅读和理解)</p>
</li>
<li><p>可扩展性(即：当需要增加新的功能时，非常方便，并且方便维护)</p>
</li>
<li><p>可靠性(即：代码需要有很好的鲁棒性，比如我们添加新功能后，对原有的代码不会产生影响)</p>
</li>
<li><p>使程序具有高内聚，低耦合的特性</p>
<a id="more"></a>
</li>
</ol>
</li>
<li><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><p>设计模式原则，其实就是<strong>程序员在编程时应该遵守的原则，也是各种设计模式的基础</strong>(即：设计模式为什么这么设计的依据)</p>
<ol>
<li><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ol>
<li><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>对类来说的，即一个类应该只负责一项原则。如类A负责两个不同的职责：职责1、职责2。当职责1需求变更而改变类A时，可能造成职责2执行错误，所以需要将类A按照职责分解为A1类和A2类，分别负责职责1和职责2。</p>
</li>
<li><h4 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对a的调用</span></span><br><span class="line">        <span class="comment">//此时对Vehicle来说，它既负责汽车的职责，也负责飞机和轮船的职责</span></span><br><span class="line">        <span class="comment">//这样就会导致飞机在公路上跑，轮船在公路上跑的错误</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"轮船"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对b的调用</span></span><br><span class="line">        RoadVehicle rv = <span class="keyword">new</span> RoadVehicle();<span class="comment">//只负责路上跑的</span></span><br><span class="line">        rv.run(<span class="string">"汽车"</span>);</span><br><span class="line">        AirVehicle av = <span class="keyword">new</span> AirVehicle();<span class="comment">//只负责天上飞的</span></span><br><span class="line">        av.run(<span class="string">"飞机"</span>);</span><br><span class="line">        BoatVehicle bv = <span class="keyword">new</span> BoatVehicle();<span class="comment">//只负责水里游的</span></span><br><span class="line">        bv.run(<span class="string">"轮船"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对c的调用</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.roadRun(<span class="string">"汽车"</span>);<span class="comment">//该方法负责路上跑的</span></span><br><span class="line">        vehicle.airRun(<span class="string">"飞机"</span>);<span class="comment">//该方法负责天上飞的</span></span><br><span class="line">        vehicle.boatRun(<span class="string">"轮船"</span>);<span class="comment">//该方法负责水里游的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//a. 违反单一职责原则的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b. 将Vehicle类改造成单一职责原则的类</span></span><br><span class="line"><span class="comment">//可以根据不同的职责将Vehicle类分解成不同的类，让每个类负责一项交通工具的职责,如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoatVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水上游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c. 但上面这种分解类的方法改动较大</span></span><br><span class="line"><span class="comment">//改进：可以直接修改Vehicle类，让其保证方法级别上的单一职责而不是类级别上的单一职责，这样改动的代码较小，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roadRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">airRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boatRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水上游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="单一职责原则补充"><a href="#单一职责原则补充" class="headerlink" title="单一职责原则补充"></a>单一职责原则补充</h4><ol>
<li>降低类的复杂度，一个类只负责一项职责</li>
<li>提高类的可读性、可维护性</li>
<li>降低变更引起的风险</li>
<li><strong>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中的方法数量足够少，才可以在方法级别保持单一职责原则。</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ol>
<li><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>客户端不应该依赖它不需要的接口，<strong>即一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
</li>
<li><h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设：类A通过接口Interface依赖类B，类C通过接口Interface依赖类D。(暗示B和D是接口Interface的实现类)</span></span><br><span class="line"><span class="comment">//假设：Interface中有5个方法fun1,fun2,fun3,fun4,fun5。</span></span><br><span class="line"><span class="comment">//假设：类A需要其中的fun1,fun2,fun3，类C需要其中的fun1,fun4,fun5</span></span><br><span class="line"><span class="comment">//那么接口Interface对于类A和类C来说都不是他们的最小接口</span></span><br><span class="line"><span class="comment">//那么很显然，类A对类B的依赖不是建立在最小的接口上，类C对类D的依赖同理</span></span><br><span class="line"><span class="comment">//即使接口Interface对于类A和类C来说不是最小接口，类B和类D也必须实现接口Interface中类A和类C不需要的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a. 违反接口隔离原则的代码</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;<span class="comment">//需要实现所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;<span class="comment">//需要实现所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB1</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB2</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB3</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD1</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD2</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun4();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD3</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.fun5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对上面进行修改，使之遵从接口隔离原则</span></span><br><span class="line"><span class="comment">//可以对接口进行拆分，然后让类A和类C分别与他们需要的接口建立依赖关系。</span></span><br><span class="line"><span class="comment">//这些接口的实现类只需要分别实现类A和类C需要的方法</span></span><br><span class="line"><span class="comment">//也就是说此时类A对类B、类C对类D的依赖都是建立在最小接口上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口拆分</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;<span class="comment">//类B实现接口1和接口2，只需要实现这两个接口中的所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B的fun3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;<span class="comment">//类D实现接口1和接口3，只需要实现这两个接口中的所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是D的fun5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB1</span><span class="params">(Interface1 i)</span></span>&#123;<span class="comment">//通过接口1依赖B，比如这里可以传入new B()</span></span><br><span class="line">        i.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB2</span><span class="params">(Interface2 i)</span></span>&#123;<span class="comment">//通过接口2依赖B，比如这里可以传入new B()</span></span><br><span class="line">        i.fun2();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependB3</span><span class="params">(Interface2 i)</span></span>&#123;</span><br><span class="line">        i.fun3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD1</span><span class="params">(Interface1 i)</span></span>&#123;<span class="comment">//通过接口1依赖D，比如这里可以传入new D()</span></span><br><span class="line">        i.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD2</span><span class="params">(Interface3 i)</span></span>&#123;<span class="comment">//通过接口3依赖D，比如这里可以传入new D()</span></span><br><span class="line">        i.fun4();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dependD3</span><span class="params">(Interface3 i)</span></span>&#123;</span><br><span class="line">        i.fun5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol>
<li><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
</li>
<li><h4 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如一个Person类实现打印消息功能</span></span><br><span class="line"><span class="comment">//未遵守依赖倒转原则的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"email 消息"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//很明显，如果我们这样写的话，Person直接依赖Email类，那么以后的拓展就会大受限制</span></span><br><span class="line">    <span class="comment">//比如我们还需要Person打印qq消息，短信消息等等，那么Person类的这个方法也需要进行修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        System.out.println(email.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对上面改进使之遵守依赖倒转原则</span></span><br><span class="line"><span class="comment">//也就是依赖抽象而不是依赖细节</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Email消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QQ</span> <span class="keyword">implements</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"QQ消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//依赖接口，这样只需要我们传入不同的实现类对象，就可以打印不同信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        System.out.println(msg.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="依赖关系传递的三种方式以及代码说明"><a href="#依赖关系传递的三种方式以及代码说明" class="headerlink" title="依赖关系传递的三种方式以及代码说明"></a>依赖关系传递的三种方式以及代码说明</h4><ol>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方法传递</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 通过接口传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV itv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangHongTV</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视打开了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV itv)</span> </span>&#123;</span><br><span class="line">        itv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过构造方法传递依赖关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangHongTV</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视打开了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV itv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV itv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.itv = itv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        itv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过setter方法传递依赖关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setITV</span><span class="params">(ITV itv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangHongTV</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视打开了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV itv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setITV</span><span class="params">(ITV itv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.itv = itv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        itv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;<span class="comment">//测试通过接口传递依赖关系</span></span><br><span class="line">        ITV changhong = <span class="keyword">new</span> ChangHongTV();</span><br><span class="line">        OpenAndClose oc = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">        oc.open(changhong);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;<span class="comment">//测试通过构造方法传递依赖关系</span></span><br><span class="line">        ITV changhong = <span class="keyword">new</span> ChangHongTV();</span><br><span class="line">        OpenAndClose oc = <span class="keyword">new</span> OpenAndClose(changhong);</span><br><span class="line">        oc.open();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;<span class="comment">//测试通过setter方法传递依赖关系</span></span><br><span class="line">        ITV changhong = <span class="keyword">new</span> ChangHongTV();</span><br><span class="line">        OpenAndClose oc = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">        oc.setITV(changhong);</span><br><span class="line">        oc.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="依赖倒转原则的补充"><a href="#依赖倒转原则的补充" class="headerlink" title="依赖倒转原则的补充"></a>依赖倒转原则的补充</h4><ol>
<li><strong>低层模块尽量都要有抽象类或接口</strong>，或者二者都有，程序稳定性更好。</li>
<li><strong>变量的声明类型尽量是接口或抽象类</strong>，这样我们的变量引用和实际对象之间，就存在一个缓冲层，利于程序拓展和优化</li>
<li>继承时<strong>遵循里氏替换原则</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ol>
<li><h4 id="OO中的继承性的思考和说明"><a href="#OO中的继承性的思考和说明" class="headerlink" title="OO中的继承性的思考和说明"></a>OO中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵守这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他类继承，则当这个类修改时，必须考虑到所有的子类，并且父类修改之后，所有涉及到子类的功能都有可能产生故障。</li>
<li>问题提出：<strong>如何在编程中正确使用继承？–&gt;里氏替换原则</strong></li>
</ol>
</li>
<li><h4 id="介绍与理解"><a href="#介绍与理解" class="headerlink" title="介绍与理解"></a>介绍与理解</h4><ol>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，<strong>所有引用基类的地方必须能透明的使用其子类的对象。</strong></li>
<li>在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不要重写父类的方法</strong></li>
<li>里氏替换原则告诉我们，继承实际上使两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题</li>
<li><strong>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义</strong>。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事</li>
<li><strong>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法</strong>，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li>
<li>不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</li>
<li><strong>如何符合LSP？总结一句话 ——就是尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ol>
<li><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>开闭原则是编程中最基础、最重要的设计原则</li>
<li>一个软件实体如类，模块和函数应该<strong>对扩展开放(提供方)，对修改关闭(使用方)</strong>。<strong>也就是说尽量在不修改原有代码的基础上实现扩展</strong>。用抽象构建框架，用实现拓展细节</li>
<li>当软件需要变化时，<strong>尽量通过拓展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</strong>。</li>
<li>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</li>
</ol>
</li>
<li><h4 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 违反开闭原则的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于绘图的类【使用方】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphEditor</span></span>&#123;</span><br><span class="line">    <span class="comment">//接受Shape对象，然后根据对象的type来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(s.type == <span class="number">1</span>) drawRec(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.type == <span class="number">2</span>) drawCir(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRec</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绘制矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCir</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绘制圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形类【提供方】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    Rec()&#123;</span><br><span class="line">        <span class="keyword">super</span>.type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆形类【提供方】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cir</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    Cir()&#123;</span><br><span class="line">        <span class="keyword">super</span>.type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如我们现在需要实现绘制三角形，通过上面的代码1，需要：</span></span><br><span class="line"><span class="comment">//1.添加三角形类</span></span><br><span class="line"><span class="comment">//2.修改GraphEditor，添加绘制三角形方法和修改drawShape，很明显，修改了使用方，违背了ocp原则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 修改上面代码使之遵循ocp原则</span></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于绘图的类【使用方】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphEditor</span></span>&#123;</span><br><span class="line">    <span class="comment">//接受Shape对象，根据不同的对象调用其draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">	    s.draw();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    Rec()&#123;</span><br><span class="line">        <span class="keyword">super</span>.type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绘制矩形"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cir</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    Cir()&#123;</span><br><span class="line">        <span class="keyword">super</span>.type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绘制圆形"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很明显，上面代码2如果想增加绘制三角形功能，只需要添加三角形类，即只需要拓展提供方</span></span><br><span class="line"><span class="comment">//不需要修改GraphEditor类，即不需要修改使用方，符合ocp原则</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ol>
<li><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。</li>
<li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要俩个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友，也就是说，陌生的类最好不要以局部变量的形式出现在当前类中</strong></li>
</ol>
</li>
<li><h4 id="代码说明-3"><a href="#代码说明-3" class="headerlink" title="代码说明"></a>代码说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回学院所有员工的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            CollegeEmployee c = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            c.setId(i);</span><br><span class="line">            res.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Employee c = <span class="keyword">new</span> Employee();</span><br><span class="line">            c.setId(i);</span><br><span class="line">            res.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(CollegeManager cm)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = cm.getAll();</span><br><span class="line">        <span class="comment">//打印逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印学校总部所有员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAll();</span><br><span class="line">        <span class="comment">//打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析：SchoolManager类的直接朋友类有Employee，CollegeManager</span></span><br><span class="line"><span class="comment">//而CollegeEmployee对SchoolManager来说是陌生类，因为它是以局部变量的形式出现在SchoolManager中的</span></span><br><span class="line"><span class="comment">//违反了迪米特法则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进：将不是直接朋友的CollegeEmployee放到CollegeManager中。</span></span><br><span class="line"><span class="comment">//即List&lt;CollegeEmployee&gt; list1 = cm.getAll();这个逻辑封装到CollegeManager类中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回学院所有员工的id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            CollegeEmployee c = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            c.setId(i);</span><br><span class="line">            res.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印学院员工信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; res = getAll();</span><br><span class="line">        <span class="comment">//打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在学校管理类中打印方法调用CollegeManager的打印方法即可</span></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Employee c = <span class="keyword">new</span> Employee();</span><br><span class="line">            c.setId(i);</span><br><span class="line">            res.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(CollegeManager cm)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印学院员工</span></span><br><span class="line">        cm.print();</span><br><span class="line">               </span><br><span class="line">        <span class="comment">//打印学校总部所有员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAll();</span><br><span class="line">        <span class="comment">//打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="迪米特法则补充"><a href="#迪米特法则补充" class="headerlink" title="迪米特法则补充"></a>迪米特法则补充</h4><ol>
<li>迪米特法则的核心是降低类之间的耦合度</li>
<li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用组合、聚合和依赖关系，少用继承关系</p>
</li>
<li><h3 id="七大设计原则总结"><a href="#七大设计原则总结" class="headerlink" title="七大设计原则总结"></a>七大设计原则总结</h3><ol>
<li>找出应用中可能需要变化之处，将它们独立出来，不要和那些不需要的变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li><strong>为了交互对象之间的低耦合设计而努力</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>offer</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池</title>
    <url>/2020/11/17/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<ol>
<li><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1></li>
</ol>
<p><img src="https://s3.ax1x.com/2020/11/27/DrxPds.png" alt="DrxPds.png"></p>
<ol start="2">
<li><h1 id="线程池基本概念"><a href="#线程池基本概念" class="headerlink" title="线程池基本概念"></a>线程池基本概念</h1><ol>
<li><p>线程池是一种池化思想的产物，如同数据库连接池。java中的常量池。</p>
<p>线程池可以帮我们管理线程、复用线程、减少线程频繁创建、销毁带来的开销。</p>
<p>在java中通常是通过ThreadPoolExecutor类来创建一个线程池，一般建议项目中自己去定义线程池，不推荐使用jdk提供的工具类Executors去构建线程池。<a id="more"></a></p>
</li>
<li><p>查看<strong>阿里巴巴开发手册</strong>中也有对线程池的一些建议：            </p>
<ul>
<li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    UserThreadFactory(String whatFeaturOfGroup) &#123;</span><br><span class="line">        namePrefix = <span class="string">"From UserThreadFactory's "</span> + whatFeaturOfGroup + <span class="string">"-Worker-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        String name = namePrefix + nextId.getAndIncrement();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">null</span>, task, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(thread.getName());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</p>
<blockquote>
<p>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
</li>
<li><p>【强制】线程池不允许使用Executors区创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的童鞋更明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>说明：Executors返回的线程池对象弊端如下：</p>
<p>1) FixThreadPool和SingleThreadPool：运行的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p>
<p>2)CachedThreadPool：运行创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><h1 id="线程池使用示例"><a href="#线程池使用示例" class="headerlink" title="线程池使用示例"></a>线程池使用示例</h1><p>这里主要就是使用调用ThreadPoolExecutor构造函数来构造一个线程池，指定自定义的ThreadFactory，里面包含我们自己线程池的poolName等信息。重写里面的execute()和submitTask()方法。 添加了系统关闭时的钩子函数shutDownHook()，在里面调用线程池的shutdown()方法，使得系统在退出(使用ctrl c或者kill -15 pid)时能够优雅的关闭线程池。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MyThreadPool<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CONCURRENT = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_POOL_NAME = <span class="string">"MyThreadPool-%d"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory FACTORY = <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(THREAD_POOL_NAME)</span><br><span class="line">            .daemon(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEP_ALIVE = <span class="number">60L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; executeQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPoolExecutor(DEFAULT_MAX_CONCURRENT, 		DEFAULT_MAX_CONCURRENT + <span class="number">2</span>, DEFAULT_KEEP_ALIVE,TimeUnit.SECONDS, executeQueue, FACTORY);</span><br><span class="line">			<span class="comment">//addShutdownHook在jvm关闭之前进行对象销毁</span></span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"MyThreadPool shutting down."</span>);</span><br><span class="line">                    executor.shutdown();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                            LOGGER.error(<span class="string">"MyThreadPool shutdown immediately due to wait timeout."</span>);</span><br><span class="line">                            executor.shutdownNow();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        LOGGER.error(<span class="string">"MyThreadPool shutdown interrupted."</span>);</span><br><span class="line">                        executor.shutdownNow();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    LOGGER.info(<span class="string">"MyThreadPool shutdown complete."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"MyThreadPool init error."</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Task executing was rejected."</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submitTask</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executor.submit(task);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Task executing was rejected."</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unable to submit the task, rejected."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h1 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h1><ol>
<li><h2 id="线程池创建的参数"><a href="#线程池创建的参数" class="headerlink" title="线程池创建的参数"></a>线程池创建的参数</h2><blockquote>
<p>ThreadPoolExecutor(int corePoolSize, </p>
<p>​                                    int maximumPoolSize,</p>
<p>​                                    long keepAliveTime, </p>
<p>​                                    TimeUnit unit,</p>
<p>​                                    BlockingQueue<runnable> workQueue, </runnable></p>
<p>​                                    ThreadFactory threadFactory, </p>
<p>​                                    RejectedExecutionHandler handler);</p>
</blockquote>
<p>corePoolSize：线程池核心线程数量。</p>
<ul>
<li>核心线程会一直存活，即使没有任务需要执行。</li>
<li>当线程数 &lt; corePoolSize，即使有线程空闲，线程池也会优先创建新线程处理任务。</li>
<li>如果设置了allowCoreThreadTimeout = true（默认false）时，核心线程才会在超时之后销毁。</li>
</ul>
<p>​        maximumPoolSize：线程池允许的最大线程数量。</p>
<ul>
<li>当线程数 &gt;= corePoolSize，且任务队列已满时。线程池会创建一个新线程，然后从工作队列的头部取出一个任务交由这个新线程来处理，而将刚提交的任务放入工作队列尾部。</li>
<li>当线程数 = maximumPoolSize，且任务队列已满时，线程池会执行拒绝策略。</li>
<li>所以线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</li>
</ul>
<p>​        keepAliveTime：空闲线程存活时间。</p>
<ul>
<li>当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。</li>
<li>如果allowCoreThreadTimeout=true，则会直到线程数量=0。</li>
<li>即一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，如果这个线程是核心线程，那么只有指定allowCoreThreadTimeout = true时，才会超时销毁，那么这里的指定时间由keepAliveTime来设定。</li>
</ul>
<p>​        unit：keepAliveTime的计量单位。</p>
<p>​        workQueue：线程池中阻塞队列，一般需指定队列大小。新任务被提交后，如果没有空闲核心线程，则会被添加到该任务队列中，任务调度时再从队列中取出任务。jdk中提供了四种任务队列：</p>
<ul>
<li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</li>
<li>LinkedBlockingQueue：基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</li>
<li>SynchronousQueue：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</li>
</ul>
<p>​        threadFactory线程工厂：创建一个新线程时使用的工厂，可以用来设定线程名、是否为Dameon线程等等。</p>
<p>​        handler：任务拒绝处理器。</p>
<ul>
<li>两种情况会执行任务拒绝处理：<ul>
<li>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制</li>
<li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕再关闭。如果在调用shutdown()和线程池真正关闭之间提交任务，会拒绝新任务。</li>
</ul>
</li>
<li>jdk提供的四种拒绝策略：<ul>
<li>CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run方法。如果线程池已经shutdown，则直接抛弃任务。</li>
<li>AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</li>
<li>DiscardPolicy：该策略下，直接丢弃任务，什么都不做。</li>
<li>DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="线程池中数据模型"><a href="#线程池中数据模型" class="headerlink" title="线程池中数据模型"></a>线程池中数据模型</h2><p>可以简化成下图，其中Thread应该是添加的一个个Worker，这里标注是为了方便理解：</p>
<p><img src="https://s3.ax1x.com/2020/11/27/DrxQoR.png" alt="DrxQoR.png"></p>
</li>
<li><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p><img src="https://s3.ax1x.com/2020/11/27/DrxNOe.png" alt="DrxNOe.png"></p>
</li>
</ol>
</li>
</ol>
<ol start="5">
<li><h1 id="ThreadPoolExecutor源码初探"><a href="#ThreadPoolExecutor源码初探" class="headerlink" title="ThreadPoolExecutor源码初探"></a>ThreadPoolExecutor源码初探</h1><ol>
<li><h2 id="ThreadPoolExecutor常用属性和方法"><a href="#ThreadPoolExecutor常用属性和方法" class="headerlink" title="ThreadPoolExecutor常用属性和方法"></a>ThreadPoolExecutor常用属性和方法</h2><p><img src="https://s3.ax1x.com/2020/11/27/DrxTpV.png" alt="DrxTpV.png"></p>
</li>
<li><h2 id="ThreadPoolExecutor部分具体代码"><a href="#ThreadPoolExecutor部分具体代码" class="headerlink" title="ThreadPoolExecutor部分具体代码"></a>ThreadPoolExecutor部分具体代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ul>
<li><p>RUNNING：</p>
<blockquote>
<p>(1)状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。</p>
<p>(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</p>
</blockquote>
</li>
<li><p>SHUTDOWN：</p>
<blockquote>
<p>(1)状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p>
<p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN</p>
</blockquote>
</li>
<li><p>STOP：</p>
<blockquote>
<p>(1)状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</p>
<p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP</p>
</blockquote>
</li>
<li><p>TIDYING：</p>
<blockquote>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p>
<p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING</p>
</blockquote>
</li>
<li><p>TERMINATED：</p>
<blockquote>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p>
<p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</p>
</blockquote>
</li>
</ul>
</li>
<li><h2 id="线程池状态转换"><a href="#线程池状态转换" class="headerlink" title="线程池状态转换"></a>线程池状态转换</h2><p><img src="https://s3.ax1x.com/2020/11/27/DrzRgK.png" alt="DrzRgK.png"></p>
</li>
</ol>
</li>
<li><h1 id="execute-源码分析"><a href="#execute-源码分析" class="headerlink" title="execute()源码分析"></a>execute()源码分析</h1><p>当有任务提交到线程池时，就会直接调用ThreadPoolExecutor.execute()方法。<a href="#线程池状态转换">执行流程</a></p>
<p>从流程图可看，添加任务会有三个分支判断，<code>java.util.concurrent.ThreadPoolExecutor.execute()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程数小于核心线程总数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//则直接创建线程并执行当前任务，如果创建成功，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//否则重新获取ctl值</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当进入这里时，说明线程数大于等于核心线程总数</span></span><br><span class="line">    <span class="comment">//如果线程池处于RUNNING状态并且任务成功添加进阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//需要重新获取ctl值，因为在这段时间线程池的状态可能已经被其他线程改变</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//重新判断线程池状态</span></span><br><span class="line">        <span class="comment">//如果线程池处于非RUNNING状态，那么线程池可能进入了SHUTDOWN状态</span></span><br><span class="line">        <span class="comment">//SHUTDOWN状态是不接受新任务的，所以需要尝试移除刚刚添加的任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">//如果移除成功，执行拒绝任务策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">//进入这个分支说明线程池处于RUNNING状态或者添加的任务已经被消费从而移除失败，如果再加上workerCountOf(recheck) == 0这个条件，那么说明阻塞队列中还有任务没消费完，但是线程池中已经没有线程，所以需要创建一个线程来维持线程池的工作，继续消费阻塞队列中的任务。</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//进入这个分支，说明此时线程池处于非RUNNING状态或阻塞队列已满从而无法向阻塞队列添加任务，那么考虑直接创建一个新的线程来处理这个任务，如果创建失败，那么可能是因为线程池中线程数大于等于maxPoolSize，那么直接执行拒绝任务策略。</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>c</code>在这里代表线程池<code>ctl</code>的值，包含工作任务数量以及线程池的状态，<a href="#ThreadPoolExecutor常用属性和方法">前面解释过</a></p>
<p>代码分析：</p>
<ol>
<li><p>分支一：if (workerCountOf(c) &lt; corePoolSize)，条件成立表示当前线程数量少于核心线程数，此次提交任务，将直接创建一个新的Worker来处理这个任务。如果线程数小于核心线程数，执行addWorker操作，后面会详细分析，如果添加成功则直接返回，失败则会重新计算ctl的值。</p>
</li>
<li><p>针对这里addWorker()方法执行失败的可能有（在addWorker源码中可以看到）：</p>
<ol>
<li>存在并发情况，<code>execute()</code>方法是可能有多个线程同时调用的，当多个线程同时<strong>workerCountOf(c) &lt; corePoolSize</strong>成立后，都会向线程池中创建<code>worker</code>，这个时候某个线程创建完<code>worker</code>后，线程池的线程总数可能已经达到核心线程数，那么其他线程<code>addWorker()</code>方法就会失败。这是在<code>addWorker()</code>方法中再次判断得到的。<img src="https://s3.ax1x.com/2020/11/27/DsPKeO.png" alt="DsPKeO.png"></li>
<li>当前线程池状态发生改变，例如线程A执行<code>addWorker()</code>方法时，线程B修改线程池状态，导致线程池不是<code>RUNNING</code>状态，此时线程A执行<code>addWorker()</code>时，会在<code>if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))</code>判断时失败，这在后面的<code>addWorker</code>源码分析时看到。<img src="https://s3.ax1x.com/2020/11/27/DsPrfs.png" alt="DsPrfs.png"></li>
</ol>
</li>
<li><p>分支二：if (isRunning(c) &amp;&amp; workQueue.offer(command)) ，通过分支一流程的分析，我们可以知道执行到这个分支说明当前线程数量已经达到<code>corePoolSize</code>或者<code>addWorker()</code>执行失败，分支二执行流程：<img src="https://s3.ax1x.com/2020/11/27/DsPbX6.png" alt="DsPbX6.png"></p>
<p>首先判断当前线程池是否处于<code>RUNNING</code>状态，如果是则尝试将<code>task</code>放入到<code>workQueue</code>中，<code>workQueue</code>是我们在初始化<code>ThreadPoolExecutor</code>时传入进来的阻塞队列。如果当前任务成功添加到阻塞队列中，再次获取<code>ctl</code>赋值给<code>recheck</code>变量，然后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<p>再次判断当前线程池是否为<code>RUNNINTG</code>状态，如果不是则说明提交任务到队列之后，线程池状态被其他线程给修改了，比如调用<code>shutdown()/shutdownNow()</code>等。这种情况就需要把刚刚提交到队列中的的任务删除掉。同时看一下remove()方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任务提交到队列之后，线程池中的线程还未将这个任务消费，那么就可以<code>remove</code>成功，调用<code>reject()</code>方法来执行拒绝策略。如果在改变线程池状态之前，队列中的数据已经被消费了，此时<code>remove()</code>就会失败。<img src="https://s3.ax1x.com/2020/11/27/DsPxtH.png" alt="DsPxtH.png"></p>
<p>如果线程处于RUNNING状态或者因为线程池状态被改变且workQueue中添加的任务已经被消费导致remove()失败，那么执行接下来来<code>else if</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>如果是<code>RUNNING</code>状态，而线程池中的线程数量是0，说明此时<code>workQueue</code>中还有待执行的任务，就需要新增一个<code>worker</code>(<code>addWorker</code>里面会有创建线程的操作)，继续消费<code>workqueue</code>中的任务。<img src="https://s3.ax1x.com/2020/11/27/DsigCd.png" alt="DsigCd.png"></p>
<p>这里要注意一下<code>addWorker(null, false)</code>，也就是创建一个线程，<strong>但并没有传入任务，因为任务已经被添加到<code>workQueue</code>中了，所以<code>worker</code>在执行的时候，会直接从<code>workQueue</code>中获取任务</strong>。在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false)</code>也是为了保证线程池在<code>RUNNING</code>状态下必须要有一个线程来执行任务，可以理解为一种担保兜底机制。</p>
<p>至于线程池中线程为何可以为0？这个如果我们设置了<code>allowCoreThreadTimeOut=true</code>，那么核心线程也是允许被回收的，后面<code>getTask()</code>中代码有提及。</p>
</li>
<li><p>分支三：else if (!addWorker(command, false)) </p>
<p>通过分支一和分之二的分析，进入这个分支的前置条件：线程数超过核心线程数且<code>workQueue</code>中数据已满。<code>else if (!addWorker(command, false))</code>，执行添加<code>worker</code>操作，如果执行失败就直接走<code>reject()</code>拒绝策略。这里添加失败可能是线程数已经超过了<code>maximumPoolSize</code>。</p>
</li>
</ol>
</li>
<li><h1 id="addWorker-源码分析"><a href="#addWorker-源码分析" class="headerlink" title="addWorker()源码分析"></a>addWorker()源码分析</h1><p>上面分析提交任务的方法<code>execute()</code>时多次用到<code>addWorker</code>方法，接收任务后将任务添加到<code>Worker</code>中。<code>Worker</code>是<code>ThreadPoolExecutor</code>中的内部类，继承自<code>AQS</code>且实现了<code>Runnable</code>接口。 类中包含<code>Thread thread</code>，它是<code>worker</code>内部封装的工作线程，还有<code>firstTask</code>属性，它是一个可执行的<code>Runnable</code>对象。在<code>Worker</code>的构造函数中，使用线程工厂创建了一个线程，当<code>thread</code>启动的时候，会以<code>worker.run()</code>为入口启动线程，这里会直接调用到<code>runWorker()</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute到addWorker流程如下图：<img src="https://s3.ax1x.com/2020/11/27/Dsi75Q.png" alt="Dsi75Q.png"></p>
<p>这里再回头看下<strong>addWorker(Runnable firstTask, boolean core)</strong> 方法，这个方法主要是添加一个<code>Worker</code>到线程池中并执行，<code>firstTask</code>参数用于指定新增的线程执行的第一个任务，<code>core</code>参数为true表示在新增线程时会判断当前活动线程数是否少于<code>corePoolSize</code>，<code>false</code>表示在新增线程时会判断当前活动线程数是否少于<code>maximumPoolSize</code>，<strong>addWorker方法整体执行流程图如下：</strong><img src="https://s3.ax1x.com/2020/11/27/DsixbT.png" alt="DsixbT.png"></p>
<p>源码分析<code>java.util.concurrent.ThreadPoolExecutor.addWorker()</code>：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//根据ctl值获得当前线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">		<span class="comment">//这个条件是非法情况的条件，分两个部分，不在这两个部分的情况则为应处理的情况：</span></span><br><span class="line">        <span class="comment">//对rs &gt;= SHUTDOWN来说，如果rs &lt; SHUTDOWN，即线程池处于RUNNING状态属于应处理情况；</span></span><br><span class="line">        <span class="comment">//对!(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())来说，</span></span><br><span class="line">        <span class="comment">//只有rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())都成立，</span></span><br><span class="line">        <span class="comment">//即线程池处于SHUTDOWN状态并且阻塞队列不为空并且没有提交的新任务为空属于应处理情况</span></span><br><span class="line">        <span class="comment">//总的来说，这个条件用来判断是否符合线程池创建任务的情况：</span></span><br><span class="line">        <span class="comment">//1. RUNNING状态可以提交任务</span></span><br><span class="line">        <span class="comment">//2. SHUTDOWN状态下如果传递的任务是空且阻塞队列中还有任务未处理的情况才允许创建任务继续处理，</span></span><br><span class="line">        <span class="comment">//因为阻塞队列中的任务仍然需要继续处理。</span></span><br><span class="line">        <span class="comment">//这个条件主要就是处理SHUTDOWN状态下任务创建操作的判断</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; </span><br><span class="line">            !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获得线程池workerCount，即线程池中线程数wc</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//这里需要判断wc是否大于可创建的最大值</span></span><br><span class="line">            <span class="comment">//然后判断wc是否大于corePoolSize/maximumPoolSize</span></span><br><span class="line">            <span class="comment">//根据传入的core参数来选择是和corePoolSize还是maximumPoolSize进行比较判断</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//接着使用compareAndIncrementWorkerCount(c)将线程池中workCount+1</span></span><br><span class="line">            <span class="comment">//这里使用的是CAS操作，如果成功则直接跳出最外层循环。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//如果CAS失败，说明此时有竞争，会重新获取ctl的值</span></span><br><span class="line">            <span class="comment">//判断竞争失败的原因是添加workCount数量还是修改线程池状态导致的</span></span><br><span class="line">            <span class="comment">//如果线程池状态未发生改变，就继续循环尝试CAS增加workCount数量</span></span><br><span class="line">            <span class="comment">//否则需要重新进入外层循环重新对线程池的状态进行判断</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里workerStarted代表worker是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//workerAdded代表创建的worker是否添加到池子中</span></span><br><span class="line">    <span class="comment">//这里所谓的池子就是全局定义的一个HashSet结构的workers变量。</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//接着根据传递的firstTask来构建一个Worker</span></span><br><span class="line">    	<span class="comment">//在Worker的构造方法中也会通过ThreadFactory创建一个线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="comment">//这里判断t != null是因为用户可以自定义ThreadFactory</span></span><br><span class="line">        <span class="comment">//如果这里用户不是创建线程而是直接返回null则会出现一些问题，所以需要判断一下。</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//在往池子中添加Worker的时候，是需要先加锁的</span></span><br><span class="line">            <span class="comment">//因为针对全局的workers操作并不是线程安全的</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//rs代表当前线程池的状态，这里还是判断线程池的状态</span></span><br><span class="line">                <span class="comment">//如果rs &lt; SHUTDOWN代表线程池状态是RUNNING状态，此时可以直接操作</span></span><br><span class="line">                <span class="comment">//如果是SHUTDOWN状态，需要满足firstTask == null才可以继续操作。</span></span><br><span class="line">                <span class="comment">//因为在SHUTDOWN状态时不会再添加新的任务，但还是可以继续处理workQueue中的任务。</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">               		<span class="comment">//t.isAlive() 当线程start后，线程isAlive会返回true</span></span><br><span class="line">               		<span class="comment">//这里还是防止自定义的ThreadFactory创建线程返回给外部之前，将线程start了</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">               		<span class="comment">//接着将创建的Worker添加到workers集合中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">               		<span class="comment">//设置largestPoolSize，这个属性是线程池生命周期内线程数最大值</span></span><br><span class="line">                    <span class="comment">//一般是做统计数据用的。</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">               		<span class="comment">//最后修改workerAdded = true</span></span><br><span class="line">                    <span class="comment">//代表当前提交的任务所创建的Worker已经添加到池子中了</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放全局锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加worker成功后，调用线程的start()方法启动线程</span></span><br><span class="line">            <span class="comment">//因为Worker中重写了run()方法，最后会执行Worker.run()</span></span><br><span class="line">            <span class="comment">//同时将workerStarted设为true表示线程已经启动</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//workerAdded = false的情形：</span></span><br><span class="line">        <span class="comment">//如果线程池在lock之前，状态发生了变化，导致添加失败</span></span><br><span class="line">        <span class="comment">//此时workerAdded也会为false，最后执行addWorkerFailed(work)操作</span></span><br><span class="line">        <span class="comment">//这个方法是将Work从workers中移除掉，然后将workCount数量减一</span></span><br><span class="line">        <span class="comment">//最后执行tryTerminate()来尝试关闭线程池</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            这里是有两层for循环，外层循环主要是判断线程池的状态，如果状态不合法就直接返回false.<br>​            只有两种情况属于合法状态：</p>
<ul>
<li><p>RUNNING状态</p>
</li>
<li><p>SHUTDOWN状态时，队列中还有未处理的任务，且提交的任务为空。SHUTDOWN含义就是不再接收新任务，可以继续处理阻塞队列的任务。</p>
</li>
</ul>
<p>​                第二层循环是通过CAS操作更新workCount数量，如果更新成功则往线程池中添加线程，这个所谓的线程池就是一个HashSet数组。添加失败时判断失败原因，CAS失败有两种原因：</p>
<ul>
<li><p>线程池状态被改变。</p>
</li>
<li><p>并发情况修改线程池中workCount数量达到指定阈值</p>
</li>
</ul>
<p>这两种情况都会导致ctl值被修改。如果是第二种原因导致的失败，继续自旋更新workCount数量。</p>
<ol start="8">
<li><h1 id="runWorker-源码分析"><a href="#runWorker-源码分析" class="headerlink" title="runWorker()源码分析"></a>runWorker()源码分析</h1><p>在<code>Worker</code>类中的<code>run</code>方法调用了runWorker来执行任务。上面<code>addWorker()</code>方法正常的执行逻辑会创建一个<code>Worker</code>，然后启动<code>Worker</code>中的线程，这里其实就会执行到<code>runWorker</code>方法。<img src="https://s3.ax1x.com/2020/11/27/DskPw8.png" alt="DskPw8.png"></p>
<p><code>runWorker</code>的执行逻辑很简单，启动一个线程，执行当前传递的<code>task</code>任务，执行完后又不断的从<code>workQueue</code>中获取任务继续执行，如果当前<code>workCount</code>数量小于核心线程数且队列中没有了任务，当前线程会被阻塞，这个就是<code>getTask()</code>的逻辑，后面会讲到。</p>
<p>如果当前线程数大于核心线程数且队列中没有任务，就会返回<code>null</code>，在<code>runWorker</code>这边退出循环，回收多余的<code>worker</code>数据。<img src="https://s3.ax1x.com/2020/11/27/DskEWj.png" alt="DskEWj.png"></p>
<p>代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里w.unlock()是为了初始化当前Work中state==0，然后设置独占线程为null，</span></span><br><span class="line">    <span class="comment">//因为在shutDown()方法中会尝试获取Worker中的锁，如果获取成功代表当前线程没有被加锁处于空闲状态，给当前线程一个中断信号。</span></span><br><span class="line">    <span class="comment">//所以这里在执行线程任务的时候需要加锁，防止调用shutDown()的时候给当前worker线程一个中断信号。</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断task是否为空，如果是一个空任务，那么就去workQueue中获取任务，如果两者都为空就会退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || </span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; 		 !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最核心的就是调用<code>task.run()</code>启动当前任务，这里面还有两个可扩展的方法，分别是<strong>beforeExecute()/afterExecute()</strong>，我们可以在任务执行前和执行后分别自定义一些操作，其中<code>afterExecute()</code>可以接收到任务抛出的异常信息，方便我们做后续处理。</p>
<p><code>runWorker()</code>中只是启动了当前线程工作，还需要源源不断通过<code>getTask()</code>方法从<code>workQueue</code>来获取任务执行。在<code>workQueue</code>没有任务的时候，根据线程池<code>workCount</code>和核心线程数的对比结果来使用<code>processWorkerExit()</code>执行清理工作。</p>
<ol start="9">
<li><h1 id="getTask-源码分析"><a href="#getTask-源码分析" class="headerlink" title="getTask()源码分析"></a>getTask()源码分析</h1><p><code>getTask</code>方法用于从阻塞队列中获取任务，如果当前线程数小于核心线程数，那么当阻塞队列中没有任务时就会阻塞，反之会等待<code>keepAliveTime</code>后返回。</p>
<p>这个就是<code>keepAliveTime</code>的使用含义：非核心的空闲线程等待新任务的时间，当然如果这里设置了<code>allowCoreThreadTimeOut=true</code>也会回收核心线程。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里核心代码就是从<code>workQueue</code>中取任务，采用<code>poll</code>还是<code>take</code>取决于<code>allowCoreThreadTimeOut</code>和线程数量，<code>allowCoreThreadTimeOut</code>在构造<code>ThreadLocalExecutor</code>后设置的，默认为false。如果设置为<code>true</code>则代表核心线程数下的线程也是可以被回收的。如果使用<code>take</code>则表明<code>workQueue</code>中没有任务当前线程就会被阻塞挂起，直到有了新的任务才会被唤醒。<img src="https://s3.ax1x.com/2020/11/27/DskgXt.png" alt="DskgXt.png"></p>
<p>在这里扩展下阻塞队列的部分方法的含义，这里主要是看<code>poll()</code>和<code>take()</code>的使用区别：</p>
<p><strong>阻塞队列插入方法：</strong></p>
<blockquote>
<p><strong>boolean add</strong>(E e)：队列没有满，则插入数据并返回true；队列满时，抛出异常 java.lang.IllegalStateException: Queue full。</p>
<p><strong>boolean offer</strong>(E e)：队列没有满，则插入数据并返回true；队列满时，返回false。</p>
<p><strong>void put</strong>(E e)：队列没有满，则插入数据；队列满时，阻塞调用此方法线程，直到队列有空闲空间时此线程进入就绪状态。</p>
<p><strong>boolean offer</strong>(E e, long timeout, TimeUnit unit)：队列没有满，插入数据并返回true；队列满时，阻塞调用此方法线程，若指定等待的时间内还不能往队列中插入数据，返回false。</p>
</blockquote>
<p><strong>阻塞队列移除(获取)方法：</strong></p>
<blockquote>
<p><strong>E remove()</strong>：队列非空，则以FIFO原则移除数据，并返回该数据的值；队列为空，抛出异常 java.util.NoSuchElementException。</p>
<p><strong>E poll()：</strong> 队列非空，移除数据，并返回该数据的值；队列为空，返回null。</p>
<p><strong>E take()：</strong> 队列非空，移除数据，并返回该数据的值；队列为空，阻塞调用此方法线程，直到队列为非空时此线程进入就绪状态。</p>
<p><strong>E poll</strong>(long timeout, TimeUnit unit)：队列非空，移除数据，并返回该数据的值；队列为空，阻塞调用此方法线程，若指定等待的时间内队列都没有数据可取，返回null。</p>
</blockquote>
<p><strong>阻塞队列检查方法：</strong></p>
<blockquote>
<p><strong>E element()：</strong> 队列非空，则返回队首元素；队列为空，抛出异常 java.util.NoSuchElementException。</p>
<p><strong>E peek()：</strong> 队列非空，则返回队首元素；队列为空，返回null。</p>
</blockquote>
</li>
<li><h1 id="processWorkerExit-源码分析"><a href="#processWorkerExit-源码分析" class="headerlink" title="processWorkerExit()源码分析"></a>processWorkerExit()源码分析</h1><p>此方法的含义是清理当前线程，从线程池中移除掉刚刚添加的<code>worker</code>对象(下图中的pool是poll)。<img src="https://s3.ax1x.com/2020/11/27/DsEQG4.png" alt="DsEQG4.png"></p>
<p>执行<code>processWorkerExit()</code>代表在<code>runWorker()</code>线程跳出了当前循环，一般有两种情况：</p>
<ul>
<li><code>task.run()</code>内部抛出异常，直接结束循环，然后执行<code>processWorkerExit()</code></li>
<li>``getTask()<code>返回为空，代表线程数量大于核心数量且</code>workQueue<code>中没有任务，此时需要执行</code>processWorkerExit()<code>来清理多余的</code>Worker`对象</li>
</ul>
<p>代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对于线程池workers的操作都会进行加锁处理</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//累加当前线程池完成的任务总数completedTaskCount</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//将当前Worker从池子中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接着调用tryTerminate()尝试关闭线程池，这个方法后面有详细说明。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//含义是当前线程池状态小于STOP，即当前线程池状态当前线程池状态为RUNNING或SHUTDOWN</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否是正常退出。如果当前线程是正常退出，那么completedAbruptly=false，</span></span><br><span class="line">        <span class="comment">//接着判断线程池中是否还拥有足够多的的线程，因为异常退出可能导致线程池中线程数量不足，</span></span><br><span class="line">        <span class="comment">//此时就要执行addWorker()为线程池添加新的worker数据</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//如果allowCoreThreadTimeOut=true,那么线程池中线程数最小可达0</span></span><br><span class="line">            <span class="comment">//如果allowCoreThreadTimeOut=false，那么线程池中线程数最小是corePoolSize</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果线程池中线程数最小是0并且任务队列不为空，说明还有任务没执行完，但是</span></span><br><span class="line">            <span class="comment">//线程池中没有了线程，所以需要重置min=1，即此时线程池最少还要有一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果线程池中线程数达到了最小的要求，那么不需要执行后面的addWorker</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行最后的addWorke()有三种可能：</span></span><br><span class="line">        <span class="comment">//1）当前线程在执行task时发生异常，这里一定要创建一个新worker顶上去。</span></span><br><span class="line">        <span class="comment">//2）如果!workQueue.isEmpty()说明任务队列中还有任务，这种情况下最起码要留一个线程，因为当前状态为RUNNING || SHUTDOWN这是前提条件。</span></span><br><span class="line">        <span class="comment">//3）当前线程数量 &lt; corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个水平。</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><h1 id="tryTerminate-源码分析"><a href="#tryTerminate-源码分析" class="headerlink" title="tryTerminate()源码分析"></a>tryTerminate()源码分析</h1><p>上面移除<code>Worker</code>的方法中有一个<code>tryTerminate()</code>方法的调用，这个方法是根据线程池状态尝试关闭线程池。</p>
<p>执行流程：<img src="https://s3.ax1x.com/2020/11/27/DsEdiD.png" alt="DsEdiD.png"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//首先是判断线程池状态：</span></span><br><span class="line">        <span class="comment">//条件一：isRunning(c)成立，直接返回就行，线程池很正常！</span></span><br><span class="line">        <span class="comment">//条件二：runStateAtLeast(c, TIDYING)说明 已经有其它线程在执行 TIDYING -&gt; TERMINATED状态了,当前线程直接回去。</span></span><br><span class="line">        <span class="comment">//条件三：(runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty())SHUTDOWN特殊情况，如果是这种情况，直接回去。得等队列中的任务处理完毕后，再转化状态。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || </span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//走到这个逻辑，说明线程池状态 &gt;= STOP或者线程池状态为SHUTDOWN且队列已经空了</span></span><br><span class="line">        <span class="comment">//当前线程池中的线程数量 &gt; 0，调用interruptIdleWorkers()中断一个空闲线程，然后返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//workerCountOf(c) == 0时会来到这里。表示最后一个退出的线程。</span></span><br><span class="line">        <span class="comment">//在(线程池状态 &gt;= STOP || 线程池状态为SHUTDOWN且队列已经空了)线程唤醒后，都会执行退出逻辑，退出过程中会先将workerCount计数减1 =&gt; ctl - 1。</span></span><br><span class="line">        <span class="comment">//调用tryTerminate方法之前已经减过了，所以workerCountOf(c) == 0时表示这是最后一个退出的线程了。</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//获取全局锁，进行加锁操作</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过CAS设置线程池状态为TIDYING状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//设置成功则执行terminated()方法,</span></span><br><span class="line">                    <span class="comment">//这也是一个自定义扩展的方法，当线程池中止的时候会调用此方法。</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//最后设置线程池状态为TERMINATED状态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//唤醒调用awaitTermination()方法的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来分析下，在<code>getTask()</code>返回为空时会执行退出逻辑<code>processWorkerExit()</code>，这里就会调用<code>tryTerminate()</code>方法尝试关闭线程池。</p>
<p>如果此时线程池状态满足<strong>线程池状态 &gt;= STOP或者线程池状态为</strong><code>SHUTDOWN</code><strong>且队列已经空了</strong>并且此时线程池中线程数不为0，就会中断一个空闲线程。</p>
<p>为什么这里只中断一个线程呢？这里的设计思想是：如果线程数量特别多的话，只有一个线程去做唤醒空闲<code>worker</code>的任务可能会比较吃力，所以，就给了每个被唤醒的<code>worker</code>线程在真正退出之前协助唤醒一个空闲线程的任务，提供吞吐量的一种常用手段。</p>
<p><code>interruptIdleWorkers()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历workers，如果线程是空闲状态(空闲状态：queue.take()和queue.poll()返回空)，则给其一个中断信号，如果是处于workQueue阻塞(queue.take()属于阻塞操作，<strong>会释放锁</strong>)的线程，会被唤醒，唤醒后，进入下一次自旋时，可能会return null执行退出相关的逻辑，接着又会调用processWorkerExit()-&gt;tryTerminate()，回到上面场景，当前线程退出的时候还是会继续唤醒下一个空闲线程。</p>
</li>
<li><h1 id="awaitTermination-源码分析"><a href="#awaitTermination-源码分析" class="headerlink" title="awaitTermination()源码分析"></a>awaitTermination()源码分析</h1><p>该方法是判断线程池状态是否达到<code>TERMINATED</code>，如果达到了则直接返回<code>true</code>，没有达到则会<code>await</code>挂起当前线程指定的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次执行<code>tryTerminate()</code>后会唤醒所有被<code>await</code>的线程，继续判断线程池状态。</p>
</li>
<li><h1 id="shutDown-shutDownNow-源码分析"><a href="#shutDown-shutDownNow-源码分析" class="headerlink" title="shutDown()/shutDownNow()源码分析"></a>shutDown()/shutDownNow()源码分析</h1><p><code>shutDown</code>和<code>shutDown()</code>方法都是直接改变线程池状态的方法，一般我们在系统关闭之前会调用此方法优雅的关闭线程池。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shutdown</code>和<code>shutdownNow</code>方法调用差不多，只是<code>shutdown</code>是将线程池状态设置为<code>SHUTDOWN</code>，<code>shutdownNow</code>是将线程池状态设置为<code>STOP</code>。<code>shutdownNow</code>会返回所有未处理的<code>task</code>集合。</p>
<p>来看看它们共同调用的一些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法是设置线程池状态为指定状态，runStateAtLeast(c, targetState)，判断当前线程池ctl值，如果小于targetState则会继续判读后面的条件。</span></span><br><span class="line"><span class="comment">//ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))，通过CAS指令，修改ctl中线程池状态为传入的targetState。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interruptIdleWorkers</code>含义是为空闲的线程设置中断标识，这里要清楚<code>worker</code>什么时候空闲？在上面 [runWorker()源码分析](#8. runWorker()源码分析)，执行<code>task.run()</code>之前，要针对<code>Worker</code>对象加锁，设置<code>Worker</code>中的<code>state</code>值为1，防止运行的<code>worker</code>被添加中断标识。接着执行<code>getTask()</code>方法，获取阻塞队列中的任务，如果是<code>queue.take()</code>则会阻塞挂起当前线程，释放锁，此时线程处于空闲状态。如果是<code>queue.pool()</code>返回为空，<code>runWorker()</code>会释放锁，此时线程也是空闲状态。</p>
<p>执行<code>interrupt()</code>后处于<code>queue</code>阻塞的线程，会被唤醒，唤醒后，进入下一次自旋判断线程池状态是否改变，如果改变可能直接返回空，这里具体参看<a href="#runWorker-源码分析">runWorker()</a>和<a href="#getTask-源码分析">getTask()</a>方法。</p>
<p><code>onShutdown()</code>也是一个扩展方法，需要子类去重写，这里代表当线程池关闭后需要做的事情。<code>drainQueue()</code>方法是获取<code>workQueue</code>中现有的的任务列表。</p>
</li>
<li><h1 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h1><ol>
<li><code>ThreadPoolExecutor</code>中常用参数有哪些？<a href="#线程池创建的参数">上面</a>介绍过了，参见的参数是指ThreadPoolExecutor的构造参数，一般面试的时候都会先问这个，要解释每个参数的含义及作用。</li>
<li><code>ThreadPoolExecutor</code>中线程池状态和线程数量如何存储的？通过AtomicInteger类型的变量ctl来存储，前3位代表线程池状态，后29位代表线程池中线程数量。</li>
<li><code>ThreadPoolExecutor</code>有哪些状态，状态之间流转是什么样子的？RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED，<a href="#线程池状态">详细参见</a></li>
<li><code>ThreadPoolExecutor</code>任务处理策略？这个问题就是考察<code>execute()</code>的执行过程，只要看过源码就不会有问题。<a href="#线程池执行流程">详细参见</a></li>
<li><code>ThreadPoolExecutor</code>常用的拒绝策略有哪些？策略处理该任务，线程池提供了4种策略：<ol>
<li>AbortPolicy：直接抛出异常，默认策略</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务</li>
<li>当然线程池是支持自定义拒绝策略的，需要实现RejectedExecutionHandler接口中rejectedExecution()方法即可。</li>
</ol>
</li>
<li><code>Executors</code>工具类提供的线程池有哪些？有哪些缺陷？<ol>
<li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>
<li>CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。所以阿里巴巴也建议我们要自定义线程池核心线程数以及阻塞队列的长度。</li>
</ol>
</li>
<li><code>ThreadPoolExecutor</code>核心线程池中线程预热功能？在创建线程池后，可以使用prestartAllCoreThreads()来预热核心线程池。</li>
<li><code>ThreadPoolExecutor</code>中创建的线程如何被复用的？这个主要是看<a href="#runWorker-源码分析">runWorker()</a>和<a href="#getTask-源码分析">getTask()</a>两个方法的执行流程，当执行任务时调用runWorker()方法，执行完成后会继续从workQueue中获取任务继续执行，以达到线程复用的效果。</li>
<li><code>ThreadPoolExecutor</code>中关闭线程池的方法<code>shutdown</code>与<code>shutdownNow</code>的区别？最大的区别就是shutdown()会将线程池状态变为SHUTDOWN，此时新任务不能被提交，workQueue中还存有的任务可以继续执行，同时会向线程池中空闲的状态发出中断信号。shutdownNow()方法是将线程池的状态设置为STOP，此时新任务不能被提交，线程池中所有线程都会收到中断的信号。如果线程处于wait状态，那么中断状态会被清除，同时抛出InterruptedException。</li>
<li><code>ThreadPoolExecutor</code>中存在的一些扩展点？钩子方法：<ol>
<li>beforeExecute()/afterExecute()：runWorker()中线程执行前和执行后会调用的钩子方法。</li>
<li>terminated：线程池的状态从TIDYING状态流转为TERMINATED状态时terminated方法会被调用的钩子方法。</li>
<li>onShutdown：当我们执行shutdown()方法时预留的钩子方法。</li>
</ol>
</li>
<li><code>ThreadPoolExecutor</code>支持动态调整核心线程数、最大线程数、队列长度等一些列参数吗？怎么操作？运行期间可动态调整参数的方法：<ol>
<li>setCorePoolSize()：动态调整线程池核心线程数</li>
<li>setMaximumPoolSize()：动态调整线程池最大线程数</li>
<li>setKeepAliveTime(): 空闲线程存活时间，如果设置了allowsCoreThreadTimeOut=true，核心线程也会被回收，默认只回收非核心线程</li>
<li>allowsCoreThreadTimeOut()：是否允许回收核心线程，如果是true，在getTask()方法中，获取workQueue就采用workQueue.poll(keepAliveTime)，如果超过等待时间就会被回收。</li>
</ol>
</li>
</ol>
</li>
<li><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol>
<li><h2 id="ThreadPoolExecutor继承体系"><a href="#ThreadPoolExecutor继承体系" class="headerlink" title="ThreadPoolExecutor继承体系"></a>ThreadPoolExecutor继承体系</h2><p><img src="https://s3.ax1x.com/2020/11/27/DsV61J.png" alt="DsV61J.png"></p>
<ol>
<li>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</li>
<li>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</li>
<li>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</li>
<li>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</li>
</ol>
</li>
<li><h2 id="阻塞队列选用"><a href="#阻塞队列选用" class="headerlink" title="阻塞队列选用"></a>阻塞队列选用</h2><p><img src="https://s3.ax1x.com/2020/11/27/DsZp9g.png" alt="DsZp9g.png"></p>
</li>
<li><h2 id="拒绝策略选用"><a href="#拒绝策略选用" class="headerlink" title="拒绝策略选用"></a>拒绝策略选用</h2><p><img src="https://s3.ax1x.com/2020/11/27/DsZ658.png" alt="DsZ658.png"></p>
</li>
<li><h2 id="动态化线程池"><a href="#动态化线程池" class="headerlink" title="动态化线程池"></a>动态化线程池</h2><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>
<p>美团技术团队得出一个可以解决业务问题的方案：动态化线程池</p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="external nofollow noopener noreferrer">动态化线程池方案及实现</a></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端必学</category>
      </categories>
      <tags>
        <tag>offer</tag>
        <tag>java后端</tag>
      </tags>
  </entry>
</search>
